<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[\[转\]计算机语言协程的历史、现在和未来]]></title>
    <url>%2F2020%2F05%2F05%2Fhistory-of-coroutine%2F</url>
    <content type="text"><![CDATA[本文原发于《程序员》2014年11月刊。好文章备份一份 计算机科学是一门应用科学，几乎所有概念都是为了理解或解决实际问题而生的。协程 (Coroutine) 的出现也不例外。协程的概念，最早可以追溯到写作 COBOL 语言编译器中的技术难题。 从磁带到协程COBOL是最早的高级语言之一，编译器则是高级语言必不可少的一部分。现如今，我们对编译器的了解，已经到了可以把核心内容浓缩成一本教科书的程度。然而在二十世纪六十年代，如何写作高效的语言编译器还是绕不过的现实问题。例如，1960年夏天，D. E. Knuth就是利用开车横穿美国去加州理工读研究生的时间，对着Burroughs 205机器指令集手写COBOL编译器。最早提出“协程”概念的Melvin Conway，也是从如何写一个只扫描一遍程序（one-pass）的COBOL编译器出发。众多的“高手”纷纷投入编译器开发，可见一门新科学发展之初也是筚路蓝缕。 以现代眼光来看，高级语言编译实际由多个步骤组合而成：词法解析、语法解析、语法树构建，以及优化和目标代码生成等。编译实质上就是从源程序出发，依次将这些步骤的输出作为下一步的输入，最终输出目标代码。在现代计算机上实现这种管道式的架构毫无困难：只需要依次运行，中间结果存为中间文件或放入内存即可。GCC和Clang编译器，以及ANTLR构建的编译器，都遵循这种设计。 在Conway的设计里，词法和语法解析不再是独立运行的步骤，而是交织在一起。编译器的控制流在词法和语法解析之间来回切换：当词法模块读入足够多的token时，控制流交给语法分析；当语法分析消化完所有token后，控制流交给词法分析。词法和语法分别独立维护自身的运行状态。Conway构建的这种协同工作机制，需要参与者“让出（yield）”控制流时，记住自身状态，以便在控制流返回时能从上次让出的位置恢复（resume）执行。简言之，协程的全部精神就在于控制流的主动让出和恢复。我们熟悉的子过程调用可以看作在返回时让出控制流的一种特殊协程，其内部状态在返回时被丢弃了，因此不存在“恢复”这个操作。 以现在眼光来看，编译器的实现并非必需协程。然而，Conway用协程实现COBOL编译器在当时绝不是舍近求远。首先，从原理上，因为COBOL并不是LL(1)型语法，无法简单构建一个以词法分析为子过程的自动机。其次，当年计算机依赖于磁带存储设备，只支持顺序存储。也就是说，依次执行编译步骤并依靠中间文件通信的设计是不现实的，各步骤必须同步前进。正是这样的现实局限和设计需要，催生了协程的概念。 自顶向下，无需协同虽然协程伴随着高级语言诞生，却没有能像子过程那样成为通用编程语言的基本元素。 从1963年首次提出到上世纪九十年代，我们在ALOGL、Pascal、C、FORTRAN等主流的命令式编程语言中都没有看到原生的协程支持。协程只稀疏地出现在Simula、Modular-2（Pascal升级版）和Smalltalk等相对小众的语言中。作为一个比子进程更加通用的概念，在实际编程中却没有取代子进程，不得不说出乎意外。但如果结合当时的程序设计思想看，又在意料之中：协程不符合那个时代所崇尚的“自顶向下”的程序设计思想，自然也就不会成为当时主流的命令式编程语言的一部分。 正如面向对象的语言是围绕面向对象的开发理念设计一样，命令式编程语言是围绕自顶向下的开发理念设计的。在这种理念的指导下，程序被切分为一个主程序和大大小小的子模块，每个子模块又可能调用更多子模块。C家族语言的main()函数就是这种自顶向下思想的体现。在这种理念指导下，各模块形成层次调用关系，而程序设计就是制作这些子过程。 在“自顶向下”这种层次化的理念下，具有鲜明层次的子过程调用成为软件系统最自然的组织方式，也是理所当然。相较之下，具有执行中让出和恢复功能的协程在这种架构下无用武之地。可以说，自顶向下的设计思想从一开始就排除了对协程的需求。其后的结构化编程思想，更进一步强化了“子过程调用作为唯一控制结构”的基本假设。在这样的指导思想下，协程没有成为当时编程语言的一等公民。 但作为一种易于理解的控制结构，协程的概念渗入到了软件设计的许多方面。在结构化编程思想一统天下之时，Knuth曾专门写过一篇《Structured Programming with GOTO》来为GOTO语句辩护。在他列出的几条GOTO可以方便编程且不破坏程序结构的例子中，有一个（例子7b）就是用GOTO实现协程控制结构。相较之下，不用GOTO的“结构化”代码反而失去了良好的结构。当然，追求实际结果的工业界对于学界这场要不要剔除GOTO的争论并不感冒。当时许多语言都附带了不建议使用的GOTO语句，显得左右逢源。这方面一个最明显的例子就是Java——语言本身预留了goto关键字，而编译器却没提供任何支持，在这场争论中做足了中间派。 实践中，协程的思想频繁应用于任务调度和流处理。例如，Unix管道就可以看成是众多命令间的协同操作。当然，管道的现代实现都以pipe()系统调用和进程间的通信为基础，而非简单遵循协程的yield/resume语法。 许多协同式多任务操作系统，也可以看成协程运行系统。说到协同式多任务系统，一个常见的误区是认为协同式调度比抢占式调度“低级”，因为我们所熟悉的桌面操作系统，都是从协同式调度（如Windows 3.2、Mac OS 9等）过渡到抢占式多任务系统的。实际上，调度方式并无高下，完全取决于应用场景。抢占式系统允许操作系统剥夺进程执行权限，抢占控制流，因而天然适合服务器和图形操作系统，因为调度器可以优先保证对用户交互和网络事件的快速响应。当年Windows 95刚推出时，抢占式多任务就被作为一大卖点大加宣传。协同式调度则等到进程时间片用完或系统调用时转移执行权限，因此适合实时或分时等对运行时间有保障的系统。 另外，抢占式系统依赖于CPU的硬件支持。因为调度器需要“剥夺”进程的执行权，就意味着调度器需要运行在比普通进程高的权限上，否则任何“流氓（rogue）”进程都可以去剥夺其他进程了。只有CPU支持了执行权限后，抢占式调度才成为可能。x86系统从80386处理器开始引入Ring机制支持执行权限，这也是为何Windows 95和Linux其实只能运行在80386之后的x86处理器上的原因。而协同式多任务适用于那些没有处理器权限支持的场景，这些场景包括资源受限的嵌入式系统和实时系统。在这些系统中，程序均以协程的方式运行。调度器负责控制流的让出和恢复。通过协程的模型，无需硬件支持，我们就可以在一个“简陋”的处理器上实现多任务系统。许多常见的智能设备，如运动手环，受硬件所限，都采用协同调度架构。 协程的复兴和现代形式编程思想能否普及开来，很大程度上在于应用场景。协程没有能在自顶向下的世界里立足，却在动态语言世界中大放光彩，这里最显著的例子莫过于Python的迭代器和生成器。回想一下在C的世界里，循环的标准写法是(i 1这行代码包含两个独立的逻辑：for循环控制了i的边界条件，++i控制了i的自增逻辑。这行代码适用于C世界里的数组即内存位移的范式，因此适合大多数访问场景。对于STL和复杂数据结构，因为往往只支持顺序访问，循环大多写成：```for (i = A.first(); i.hasNext(); i = i.next()) &#123; ... &#125; 这种设计抽象出了一个独立于数据结构的迭代器，专门负责数据结构上元素的访问顺序。迭代器把访问逻辑从数据结构中分离出来，是一个常用的设计模式（GoF 23个设计模式之一），我们在STL和Java Collection中也常常看到迭代器的身影。在适当的时候，我们可以更进一步引入一个语法糖，将循环写成：for i in A.Iterator() {func(i)} 事实上，许多现代语言都支持类似的语法。这种语法抛弃了以i变量作为迭代指针的功能，要求迭代器自身能记住当前迭代位置，调用时返回下一个元素。读者不难看到，这就是我们在文章开始提到的语法分析器的架构。正因为如此，我们可以从协程的角度来理解迭代器：当控制流转换到迭代器时，迭代器负责生成和返回下一个元素。一旦准备就绪，迭代器就让出控制流。在Python中，这种特殊的迭代器实现又被成为生成器。以协程角度切入的好处在于设计大大精简。实际上，在Python中，生成器本身就是一个普通函数，和其他普通函数的唯一不同，在于它的返回语句是协程风格的yield。这里，yield一语双关，既是让出控制流，也是生成迭代器的返回值。 前文我们仅讨论了生成器最基本的特性。实际上，生成器的强大之处在于我们可以像Unix管道一样串联起来，组成所谓的生成器表达式。如果我们有一个可以生成1，2，3 …的生成器N，则square = (i 2 for i in N)就是一个生成平方数的生成器表达式。注意这里圆括号语法和list comprehansion方括号语法的区别，square = [i 2 for i in N]是生成一个具体的列表。我们可以串联这些生成器表达式，最终的控制流会在这些串联的部分间转换，无需编写复杂的嵌套调用。当然，yield只是冰山的一角，现代的Python语言还充分利用了yield关键字构建yield from语句、(yield)语法等，让我们毫无困难地将协程的思想融入到Python编程中，限于篇幅这里不再展开。 我们前面说过，协程的思想本质上就是控制流的主动让出和恢复机制。在现代语言中，可以实现协程思想的方法很多，这些实现间并无高下之分，所区别的就是是否适合应用场景。理解这一点，我们对于各种协程的分类，如半对称/对称协程、有栈与无栈协程等具体实现就能提纲挈领，无需在实现细节上纠结。 协程在实践中的实现方式千差万别，一个简单的原因是，协程本身可以通过许多基本元素构建。基本元素的选取方式不一样，构建出来的协程抽象也就有差别。例如，Lua语言选取了create、resume和yield作为基本构建元素，从调度器层面构建出所谓的“非对程”协程系统；而Julia语言绕过调度器，通过在协程内调用yieldto函数完成了同样的功能，构建出了一个所谓的对称协程系统。尽管这两种语言使用了同样的setjmp库，构造出来的原语却不一样。又如，许多C语言的协程库都使用了ucontext库实现，这是因为POSIX本身提供了ucontext库，不少协程实现是以ucontext为蓝本实现的。这些实现，都不可避免地带上了ucontext系统的一些基本假设，如协程间是平等的，一般带有调度器来协调协程等（如libtask实现，以及云风的coroutine库）。Go语言的一个鲜明特色就是通道（channel）作为一级对象。因此，resume和yield等在其他语言里的原语在Go中都以通道方式构建。我们还可以举出诸多近似的例子。其风格差异往往和语言的历史、演化路径、要解决的问题相关，我们不必苛求其协程模型一定要如此这般。 总的来说，协程为协同任务提供了一种运行时抽象。这种抽象非常适合于协同多任务调度和数据流处理。在现代操作系统和编程语言中，因为用户态线程切换代价比内核态线程小，协程成为了一种轻量级的多任务模型。我们无法预测未来，但可以看到，协程已成为许多擅长数据处理语言的一级对象。随着计算机并行性能的提升，用户态任务调度已成为一种标准的多任务模型。在这样的大趋势下，协程这个简单且有效的模型就显得更加引人注目。]]></content>
      <tags>
        <tag>coroutine</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是协程？]]></title>
    <url>%2F2020%2F05%2F05%2Fcoroutine%2F</url>
    <content type="text"><![CDATA[Kotlin中的协程虽然会用，但也一直停留在表层Api。没有仔细探究过其思想以及实现，使用起来也会比较虚，心里没底。所以很有必要对其一探究竟，揭一揭它的面纱 协程的定义协程: Coroutine协程的出现，可以追溯到1958年，它由马尔文·康威提出用于构建汇编程序，而且它的出现要早于线程。 定义Wiki: : Coroutines are computer program components that generalize subroutines for non-preemptive multitasking, by allowing execution to be suspended and resumed. Coroutines are well-suited for implementing familiar program components such as cooperative tasks, exceptions, event loops, iterators, infinite lists and pipes 译: 协程时计算机程序的一类组件，通过允许挂起和恢复执行概括了非抢占式（即协作式）多任务的子程序。协程非常适合用于实现一些常见的程序组件，如协作式多任务，异常，事件循环，迭代器，无限列表以及管道 Wiki中对于协程的定义还是挺难理解的，其中的关键词 子程序（subroutine） 挂起（suspend）和恢复（resume） 抢占式（preemptive）和协作式（cooperative or non-preemptive） 如果不先理解这几个关键词的话，是很难搞清楚协程的 首先是子程序《The Art of Computer Programming》(计算机程序设计艺术)一书中对subroutine有详细的解释，以下是原文 When a certain task is to be performed at severial different places in a program, it is usually undesirable to repeat the coding in each place. To avoid this situation, the coding (called a subroutine) can be put into one place only, and a few extra instructions can be added and to restart the outer program properly after the subroutine is finished 译: 当一项确定的任务再程序的不同位置多次执行时，通常重复的代码不是我们想看到的。为了避免这种情况，这段代码（叫做一个子程序）可以被单独放在一个位置，通过少量额外的指令在每个需要执行该此程序的位置添加并执行子程序，并在子程序执行完成后，自动的重启外部程序 这段对于子程序的描述还是很容易理解的，从高级语言的角度来看，子程序就相当于一个函数或方法，对子程序的引用即为对函数或方法的调用。 子程序的用途书中也有描述，这里简单提一下：子程序的主要优势是避免重复代码，节省程序空间。也间接的节省了时间，如：加载程序需要的时间减少等。子程序也会让构思大型程序变得更容易，debug也会更容易。封装出来的子程序也可以作为开放库对外暴露给其他开发者使用。 理解了子程序，那么子程序跟协程又有什么关系呢？或者说两者有什么区别呢？同样引用原文给出答案 Subroutines are special case of more general program components, called coroutines. In contrast to the unsymmetric relationship between a main routine and a subroutine, there is complete symmetry between coroutines, which on call each other. We may consider the main program and subroutines as a team of programs, each member of the team having a certain job to do. The main program, in the course of doing its job, will activate the subprogram; the subprogram will perform its own function and then activate the main program. We may stretch our imagination to believe that, from the subroutine’s point of view, when it exits it is calling the main routine; the main routine continues to performs its duty, then ‘exits’ to the subroutine. the subroutine acts, then call the main routine again. 译: 子程序是通用程序组件（即协程）的一种特例。与主程序与子程序间非对等关系（调用者与被调用者）对比，协程间是完全对等的，他们可以互相调用 我们可以将主程序和子程序看作是程序组，程序组中的每个成员都要完成特定的任务。主程序在完成其任务的过程中，会激活子程序，然后子程序会执行完成它自己的任务，随后再激活主程序让主程序继续执行。拓展下我们的想象力，从子程序的视角出发，在子程序出口位置调用主程序，主程序继续执行其任务，接着主程序’退出’并在出口位置调用子程序，子程序执行，而后再调用主程序 上面第二段的意思是，子程序只有一个入口和出口，而协程可以有多个入口和出口。即子程序被主程序调用后只能从头开始执行（入口）直到执行完成然后退出（出口），而后主程序继续执行。而协程在被调用后，在中途可能会有一个或多个出口（出口点之后仍然有代码待执行），当执行中途遇到出口时，当前协程交出执行权让其他协程执行，当下次再调用该协程时，会从上次的出口点位置继续开始执行后续的代码（上次的出口点即为下次执行的入口点）。这也就解释了第一段中子程序和主程序关系与协程间关系的差别了 Wiki中子程序与协程的比较 子例程可以调用其他子例程，调用者等待被调用者结束后继续执行，故而子例程的生命期遵循后进先出，即最后一个被调用的子例程最先结束返回。协程的生命期完全由对它们的使用需要来决定 子例程的起始处是惟一的入口点，每当子例程被调用时，执行都从被调用子例程的起始处开始。协程可以有多个入口点，协程的起始处是第一个入口点，每个yield返回出口点都是再次被调用执行时的入口点。 子例程只在结束时一次性的返回全部结果值。协程可以在yield时不调用其他协程，而是每次返回一部分的结果值，这种协程常称为生成器或迭代器。 现代的指令集架构通常提供对调用栈的指令支持，便于实现可递归调用的子例程。在以Scheme为代表的提供续体的语言环境下，恰好可用此控制状态抽象表示来实现协程。 挂起和恢复其实在子程序那一部分中已经对挂起和恢复做出了解释。协程拥有多个出口和入口，所谓挂起就是在执行途中遇到出口，当前协程让出执行权，跳转到其他协程继续执行，而恢复就是当再次调用该协程时从上次出口点继续执行后续任务。出口对应挂起，入口对应恢复 抢占式和协作式首先，无论是抢占式还是协作式，都意味着当前Task都不再继续拥有执行权，而两者区别是，抢占式多任务中，当前任务被动的系统剥夺执行权，协作式多任务中，当前任务在不需要系统资源时主动让出执行权 抢占式多任务涉及到了中断机制的使用，中断机制可以挂起当前进程并唤起调度器以决定接下来应该调度执行哪个进程。因此，所有进程在一段时间内都会获得一定数量的CPU时间 抢占式多任务依赖于 CPU 的硬件支持。 因为调度器需要“剥夺”进程的执行权，就意味着调度器需要运行在比普通进程高的权限上，否则任何“流氓（rogue）”进程都可以去剥夺其他进程了。只有 CPU 支持了执行权限后，抢占式调度才成为可能 不同于抢占式由系统调度进程切换，协作式进程在空闲（idel）或阻塞（block）时会主动的让出执行权（yield） 协程能解决什么问题呢如果从早先协程的设计理念来看，协程是设计用来处理单内核下多任务并发的。协程最本质的特性是可挂起和恢复的特性，拥有多入口多出口。相较于子程序的从头运行至尾，协程有更丰富的过程（有一个或多个运行阶段）,多个任务可以交替执行，使得多任务协作提供成为可能，即协程拥有并发的能力。 而对于现代的高级语言来说，协程更像是任务，运行在线程之上，在语言级别进行调度。许多语言的也都是多线程 + 协程的的实现，以达到像写同步代码那样处理异步问题。通常异步需要多线程来实现，但是弊端就是多线程调度时，切换上下文较为耗时，而如果通过多线程 + 协程方式来处理异步的话，相当于将系统级的线程调度替换为语言级别的协程调度，一定程度上减少了多线程调度切换上下文的开销。另一方面，多线程方式实现异步最可能面临异步回调，而最熟悉的应该是JS中的回调地狱问题了，而有了协程之后，就可以完美的消除该问题。 简单总结协程从本质上讲依然是一种程序，运行与线程之上。名称以及它表现出来的特征与线程有相似之处，但与线程不同的是，他的调度并不需要系统参与，而是直接在语言级别完成。这也是许多人称协程为用户级线程的原因]]></content>
      <tags>
        <tag>coroutine</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub Pages + Hexo搭建博客汇总]]></title>
    <url>%2F2019%2F08%2F18%2Fhexo_github_pages%2F</url>
    <content type="text"><![CDATA[网上关于GitHub Pages + Hexo搭建博客的教程较多，因此此文旨在查缺补漏，记录整个流程，汇总一些参考的优质blog，以及梳理我在搭建过程中遇到的问题。 如何搭建个人blog在开始之前，我先想了下如何搭建个人blog。既然blog是个网站，那么首先能想到的是，需要自己开发一个网站出来啊，有了网站，还需要服务器来部署我们的网站，然后还需要一个域名，方便访问我们的网站。 因此我们要做的工作有 开发自己的网站（网站设计，UI开发，评论统计系统集成维护等） 搭建服务器（部署网站，维护等） 购买域名（绑定域名） 首先开发网赚需要耗费巨大精力，其次购买服务器和域名都需要花钱，而我的初衷只是写blog啊，然而却需要做这么多，那岂不是舍本逐末了。好在已经有现成且免费的框架和工具，GitHub Pages和Hexo帮我们做了上面几乎所有的事儿 GitHub Pages介绍GitHub Pages是Github提供的一个免费静态网站的托管服务，旨在直接从GitHub仓库托管个人/组织/项目的页面，并且为站点提供了默认域名github.io。也就是说GitHub Pages帮我们解决了 服务器和域名 这两大难题 详细介绍：GitHub Pages官网 Hexo介绍Hexo是一款基于Node.js的静态博客框架。通过Hexo，用户可以定制自己喜欢的网站主题，专注与使用Markdown编写blog，它会帮用户生成静态网站并托管在GitHub，相当的简便。因此Hexo帮我们解决了 开发网站 的难题 详细介绍：Hexo中文文档 搭建个人blog的流程在使用Hexo极力推荐阅读 Hexo中文文档 ,文档里的说明要比许多blog里清晰的多 搭建前的准备工作安装流程在上文中的Hexo中文文档里有详细说明 安装Git 安装Node.js 安装Hexo 搭建流程这里只列出简单流程，定制主题，及git分支设置在后面介绍 GitHub上创建新仓库，仓库名为 GitHub用户名.github.io 这里需要注意，仓库的名字必须为上面的格式，否则部署后将无法访问blog GitHub新建分支hexo，并设置为默认分支 使用Git克隆新建仓库到本地（此时为hexo分支） 1$ git clone https://github.com/github_user_name/github_user_name.github.io.git 在仓库根目录使用hexo init命令初始化（此时为hexo分支） 1$ hexo init 上一步完成后依次使用hexo g 与 hexo s（此时为hexo分支），其中g为generator，s为server 12$ hexo g$ hexo s 打开浏览器输入localhost:4000查看本地blog效果，如下图 修改仓库根目录下的_config.yml文件，修改deploy中的以下字段并保存，注意branch要设置为master 1234deploy: type: git repo: https://github.com/github_user_name/github_user_name.github.io.git branch: master 提交本地变更至hexo分支 123$ git add .$ git commit -m 'commit msg'$ git push origin hexo 使用hexo d命令完成blog部署 1$ hexo s blog目录结构在上面流程的第4步中，执行完hexo init命令后，会在文件夹下生成hexo工程，以下简要展示生成的目录结构及各个目录的作用，更为详细的解释见Hexo目录结构123456789|-- _config.yml // 网站全局配置文件，详细说明见|-- package.json //|-- scaffolds //|-- source // 网站资源文件夹，存放网站图片，文章等 |-- _drafts |-- _posts // 我们的Markdown和HTML文件存放在次文件夹|-- themes |-- landscape // 官方默认的主题 |-- next // next主题 经过第4步之后，通过修改_config.yml文件进行网站的配置,如网站title，author等，详情见Hexo网站配置。其中最应该注意的是deploy字段，该字段用于配置网站的部署，如网站部署到git的xxx仓库的xxx分支，或是地址为xxx.xxx.xxx.xxx的服务器，详情见Hexo deploy 设置主题Hexo允许用户自定义主题，下面展示主题的设置方式 挑选自己喜欢的主题，找到其仓库地址 命令行cd 定位到themes文件夹，将主题clone至该文件夹 12$ cd themes$ git clone &lt;theme repo&gt; 在clone完成后，新添加的文件夹名称即为主题名称xxx，打开_config.yml将theme字段的landscape修改为xxx 关于主题的挑选，如果没有web前段经验，最好挑选那些star数计较高，社区比较活跃，经常迭代维护的主题，如我自己使用的next主题，下面是我在挑选主题时参考的资料 知乎-有哪些好看的Hexo主题 高赞回答用python爬虫爬出来的主题star排行榜 ,推荐参考这个挑选主题 官方主题列表 官方没有对主题进行排名，挑选时稍微麻烦些 推荐NexT主题 NexT主题外观比较简洁利落，并且社区活跃，有详尽的中文文档，主题的外观也可进行各种灵活的配置，是前段盲的必备良药。对于该主题的详细用法，其官方文档中有详细的说明，也就不再赘述了 关于git仓库的说明在搭建流程中的前两步，建立完仓库后，又新建了一个hexo分支，并且设置为默认分支。这是因为我们在维护我们的网站时，要维护以下两部分内容 Hexo工程 1hexo init之后生成的部分 生成的静态网站 1之前在_config.yml中配置了deploy的git仓库及分支，这里我配置的是master分支，在执行了hexo deploy命令之后，Hexo就会生成静态静态网站提交至master分支并自动部署 这两部分都需要提交至git仓库的，第一部分提交至git，我们就可以随时随地只要有电脑网络就可以clone工程，写blog并更新网站。第二部分是GitHub Pages部署网站必须的部分。这两部分的内容互不相干，因此建议新建hexo分支，用于存储我们的Hexo工程，master分支用于部署网站 参考的文档：知乎-使用Hexo，如果换了电脑怎么更新博客 关于NexT主题个人签名不显示的问题在NexT主题配置文件_config.yml中，如果设置seo字段为true，则网站配置文件_config.yml中的description字段会被用于seo，而不会显示为签名，这时如果想要显示个人签名，需要额外添加signature字段1signature: 随行、随记 Hexo SEO优化辛辛苦苦搭好了blog，写了文章，最后发现浏览器里搜不到啊，根本没人看啊，怎么办啊，好没有成就感。这时候就需要SEO出马了，那么什么是SEO呢？ SEO 英文全称Search Engine Optimization 即搜索引擎优化。是一种利用搜索引擎规则提高网站在有关引擎内的自然排名 既然是针对搜索引擎的优化，那么也就是针对Baidu和Google的优化了。相关blog有很多，并且都是死套路，所以这里就挑选几篇比较新比较好的blog列出来 Hexo博客Next主题SEO优化方法Hexo个人博客SEO优化系列]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub Pages</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F08%2F18%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BIP 32]]></title>
    <url>%2F2018%2F09%2F27%2Fbip32%2F</url>
    <content type="text"><![CDATA[此篇为BIP 32的译文，介绍分层确定性钱包原文链接 概述本文介绍分层确定性钱包（HD Wallet）：一种可以在不同系统间部分或全部共享，有或没有花费的能力的钱包 该规范旨在为可在不同客户端之间通信的确定性钱包设定标准。虽然本文描述的钱包有很多特性，但对于钱包客户端来说并不是每个特性都需要实现 本文分为两部分 第一部分主要介绍如何从单一种子派生出一颗秘钥树 第二部分主要介绍如何利用派生出来的秘钥树构建钱包 动机非确定性钱包的缺点现有的一些Bitcoin客户端使用随机生成的秘钥，为了避免为每笔交易后都进行备份，这些客户端会创建一个（默认）包含100个秘钥的秘钥池。并且这种钱包很难跨系统共享，或者多端同时使用。虽然可以使用钱包的加密特性隐藏私钥并且不共享密码，但是这也导致钱包失去了生成公钥的能力。 确定性钱包及非确定钱包确定性钱包不需要如此高频率的备份，而且由于椭圆曲线的数学特性，他可以在不暴露私钥的情况下计算出公钥。该特性就当于一个网络商店商家可以让他的服务器为每个顾客或每笔订单都生成一个新地址（即公钥hash），并且服务器不需要获取私钥。然而，确定性钱包只有一条密钥对链组成。这个事实意味着钱包只能全部共享或不共享两种选择。但是在某些场景下我们只希望共享部分密钥（如只共享公钥）。还是拿网络商店举例，网络服务器并不需要访问商户的所有公钥，他们只需要获取用于接受客户付款的地址对应的公钥，而不是商户消费时生成的找零地址。而分层确定性钱包支持从单一root多条密钥链的特性，使得选择性的分享成为了可能。 密钥生成规范约定在本文的其余部分，我们将假定比特币中使用的公钥加密算法，即为secp256k1定义的字段和曲线参数椭圆曲线加密算法。变量如下 整数模数曲线顺序（用n表示） 曲线上点的坐标 字节序列另外两个坐标的加法（+）定义为EC组操作的应用级联（||）是把一个字节序列附加到另一个字节序列的操作 作为标准的转换函数，我们假设 point(t):返回secp256k1基点与EC点做乘法（重复应用EC组操作）得到的坐标对与整数p。 ser32(i):把一个32位的无符号整数序列化为一个4字节序列，高位在前 ser256(p):把一个整数序列化为一个32字节序列，高位在前 serP(P):使用SEC1的压缩格式将坐标对p(x,y)序列化为字节序列：(0x02 or 0x03) || ser256(x),其中头部字节为y坐标的奇偶校验 parse256(p):将32字节序列转化为一个256位数字，高位字节优先 扩展密钥接下来，我们顶一个一个函数，该函数可以从一个给定的父密钥派生出一定数量的子密钥。为了防止派生密钥仅依赖父密钥本身，我们会额外加入一个256位的熵对私钥与公钥进行扩展。熵称之为链码，链码对于相应的公私钥是相同的，都为32字节我们把一个扩展私钥表示为(k,c)，k为普通私钥，c为256位的熵。扩展公钥表示为(K,c)，其中K=point(k)，c为256位的熵每个扩展密钥有231个普通子密钥，以及231个强化子密钥，每个密钥都有一个下标。普通密钥的下标为0 - 231-1，强化密钥的下标为231 - 232-1，为了方便，我们使用i(H)来标记强化密钥，iH = i + 231 子密钥派生函数（CKD：child key derivation）给定一个父扩展密钥及其下标i，可以计算出相应的子扩展密钥，算法取决于子扩展密钥是否是一个强化密钥（或即i是否&gt;=2^31），以及我们是否在讨论私钥或公钥 父私钥 -&gt; 子私钥函数CKDpriv((kpar, cpar), i) &rarr; (ki, ci) 判断下标i是否大于等于231，如果满足则为强化子密钥，计算I = HMAC-SHA512(Key = cpar, Data = 0x00 || ser256(kpar) || ser32(i))（注意：0x00为填充字节，保证私钥长度为33字节），如果不满足则为普通子密钥，计算I = HMAC-SHA512(Key = cpar, Data = serP(point(kpar)) || ser32(i)) 将I分为两个32字节序列，IL和IR 返回的子密钥ki = parse256(IL) + kpar (mod n) 链码(熵)ci为IR 在parse256(IL) ≥ n 或 ki = 0的情况下，生成的密钥是无效的，这时应该继续计算下一个子密钥(发生的概率小于 1/2127) HMAC-SHA512函数，可查看RFC 4231 父公钥 -&gt; 子公钥函数CKDpub((Kpar, cpar), i) &rarr; (Ki, ci)，仅适用于普通子密钥 判断下标i是否大于等于231，如果满足则返回失败，如果不满足则为普通子密钥，计算I = HMAC-SHA512(Key = cpar, Data = serP(Kpar) || ser32(i)) 将I分为两个32字节序列，IL和IR 返回的子密钥ki = point(parse256(IL)) + Kpar 链码(熵)ci为IR 在parse256(IL) ≥ n 或 Ki是无穷远的一个点时，这时应该继续计算下一个子密钥 父私钥 -&gt; 子公钥函数N((k, c)) &rarr; (K, c)计算出与扩展私钥相对应的扩展公钥 返回值K = point(k) 返回链码(熵)c即为函数输入中传递过来的链码 两种通过父私钥计算子公钥的方法 N(CKDpriv((kpar, cpar), i))(适用于任何条件) CKDpub(N(kpar, cpar), i)（仅适用于生成普通子公钥） 父公钥 -&gt; 子私钥不可能 密钥树下一步我们使用若干个CKD结构构建一颗密钥树。从单一根节点开始，即主密钥m，对多个i计算CKDpriv(m,i)，进而得到1级派生子密钥。由于派生出来的密钥也都是扩展密钥，所以CKDpriv也可以应用于这些密钥。 为了方便书写，我们把CKDpriv(CKDpriv(CKDpriv(m,3H),2),5)简写为m/3H/2/5，同样的，对于公钥，我们把CKDpub(CKDpub(CKDpub(M,3),2),5)简写为M/3/2/5。因此有了下面的等式 N(m/a/b/c) = N(m/a/b)/c = N(m/a)/b/c = N(m)/a/b/c = M/a/b/c. N(m/aH/b/c) = N(m/aH/b)/c = N(m/aH)/b/c. 但是，N(m/aH)不能写为N(m)/aH，因为我们无法通过父扩展公钥计算出子扩展私钥 每个叶子节点都对应于一个真正的密钥，叶子节点的链码会被忽略，只有节点中的公私钥是有用的。因为这种结构，我们有了父扩展私钥，就可以计算出所有的子扩展公钥及子扩展私钥，知道了父扩展公钥，就可以计算出所有的非强化子扩展公钥 密钥id可以使用序列化的ECDSA公钥的Hash160作为扩展密钥的id，忽略链码。id对应于比特币中地址。不建议使用Base58对id进行编码，因为id可能被作为地址（并且钱包软件不需要接受对链密钥本身的付款）。 密钥id的钱32位称为指纹 扩展密钥序列化格式扩展公钥及扩展私钥格式如下 4byte：版本号(主网: 0x0488B21E public, 0x0488ADE4 private; 测试网: 0x043587CF public, 0x04358394 private) 1byte：深度，根节点：0x00，一级节点：0x01 以此类推 4byte：父密钥的指纹(主密钥为0x00000000) 4byte：子节点个数(这里的英文看不懂 T T) 32byte：链码 33byte：原生公私钥数据(公钥部分为serP(K)，私钥部分为0x00 || ser256(k)) 这78byte的数据可以像比特币其他数据一样使用Base58进行编码，首先要添加32位的校验码(通过两次SHA-256生成)，然后转为Base58编码格式，编码后输出长度为112位的字符串。版本号部分经过Base58编码，对应的字符串为，主网：xprv、xpub，测试网：tprv、tpub 注意：上面格式中父密钥的指纹仅为了方便软件(钱包)检测父子节点使用，并且软件需要处理冲突，在内部，可以使用完整的160位id。 在导入序列化扩展公钥时，必须验证公钥数据中的X坐标是否存在于椭圆曲线上。 如果不是，则扩展公钥无效 主密钥生成可能的扩展密钥对总数几乎为2512，但是生成出来的密钥为256位，所以安全性会折半。主密钥并不是直接生成的，而是使用已有的种子代替。主密钥生成步骤如下： 使用prng算法生成种子序列S，长度为128 - 512位之间。建议使用256位 计算I = HMAC-SHA512(Key = “Bitcoin seed”, Data = S)，直接使用比特币种子作为输入 将I分为两个32字节序列，IL and IR 使用parse256(IL)作为主私钥，IR作为主链码 在IL = 0 或 ≥n的情况下，生成的主密钥无效，需要重新生成 分层确定性钱包结构前面的部分中描述了密钥树及其节点，下一步是在此基础上构建一个钱包。本文中介绍的仅为一种范例，但是建议开发者开发钱包时模仿范例的兼容性，但也不是所有的功能都需要支持 范例钱包的结构一个HDW可以看做一系列账户的集合，每个账户都有个编号，默认账户account(“”)的编码为0。钱包可以不支持多账户，如果不支持，则使用默认账户。 每个账户都是两条密钥链组成：内部链，外部链。外部链用来生成新的公共钱包地址，内部链可用于所有其他的操作(更改地址，生成地址，可以是任何不需要通信的操作)，支持双密钥链的钱包，应该使用外部链以支持所有的操作 m/iH/0/k 为从主密钥m导出的第i个账号的外部链的第k个密钥对 m/iH/1/k 为从主密钥m导出的第i个账号的内部链的第k个密钥对 用例全钱包共享在两个系统需要访问同一个钱包，并且两个系统都需要有花费的功能，则需要共享主扩展私钥。每个网络节点需要为外部链维护一个前瞻密钥缓池，其中保存n个前瞻密钥，用于监听收到的付款。对内部内部链的展望可能非常小，因为不存在任何缺口。注意账户名无法通过区块链同步，仍然需要手动输入。 审计如果一名审计员需要获取所有交易(收支)记录，则可以将所有账户的扩展公钥共享给审计员。这样审计员就可以查看当前钱包的所有交易(收支)了 公司多部门场景当一家公司拥有数个独立的部门，则这些部门可以使用从同一主密钥派生出来的钱包。进而公司的领导通过维护一个超级钱包，就可以看到各个部门的收支情况了，甚至可以在各部门之间转移资金 合作企业间交易可以使用特定账户的外部链的扩展公钥作为“超级地址”，可以使得即使高频交易也不容易被别人追踪到，但无需为每笔付款都申请一个新地址。矿池操作员也可以使用这种机制作为可变支付地址 不安全的收款人当运行电子商务的服务器，存在安全风险时，他需要知道用于收款的公共地址。服务器只需要知道单个账户外部链扩展公钥。这意味着非法访问网络服务器的人最多只能查看交易记录，但是无法盗取资金，如果存在多台服务器，则他只攻破一台服务器，也无法访问到其它服务器的交易记录]]></content>
      <tags>
        <tag>区块链</tag>
        <tag>BIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BIP 39]]></title>
    <url>%2F2018%2F09%2F13%2Fbip39%2F</url>
    <content type="text"><![CDATA[进入区块链行业已经一年有余，开发之余也一直在补充区块链知识，读过《区块链-技术驱动金融》，以及BTC白皮书BIP等，记录的比较零散，很有必要整理一下。首先先把比较重要的BIP翻译整理一遍。此篇BIP39的译文，是助记词相关知识 原文链接 概要此篇BIP介绍如何为确定性钱包生成助记词或者助记句（一组容易记忆的单词）本文包括两部分： 生成助记词 将助记词转化为二进制种子。种子可以用于生成BIP 32中所描述的确定性钱包 动机原生的二进制信息/十六进制的钱包种子，对人们来说是很难记录并保存的，而且在保存的过程中也容易出错。如果换成一组单词或句子，则友好的多。句子可以很方便的写在纸上或其他隐秘的地方 生成助记词第一步 – 生成初始熵熵的位数必须为32的整数倍。熵越长，越安全，相应的助记词也就越多。这里定位熵的长度为ENT，ENT的取值范围为128位-256位 第二步 – 计算校验和计算方式，对初始熵计算SHA256 hash，取其前 ENT/32 位作为校验和CS。 第三部 – 生成助记词然后将校验和拼接在初始熵的尾部，即ENT+CS位数据，再划分为整数个11bit组，即（ENT+CS）/ 11组，记为MS，每个组可以编码为0-2047中的一个正整数，刚好对应于助记词表中的一个单词的下标。然后将分组按照下标转换为一组助记词 下图描述了ENT，CS，MS的关系 助记词表一个理想的助记词表应该拥有以下特性 选词聪明 所选的词应该满足通过单词的前四个字符就可以确定该单词 避免相近次出现 如’build’/‘built’、’woman’/‘women’、’quick’/‘quickly’。这类相似词，不仅让记忆句子变得困难，而且也更容易出错 助记词列表需要排序 有序的助记词列表，可以让词查找更加有效率，同时也可以使用前缀树，以便更好的压缩 注：助记词表可以包含本地字符，但是必须使用（NFKD）UTF-8编码 助记词转化为种子（seed）有些用户可能想用passphrase对助记词进行加密。如果没有设置passphrase则使用“”空字符代替生成种子使用的是PBKDF2算法该算法的该算法的输入为 助记词作为password参数 “mnemonic”+passphrase作为salt参数 迭代次数设置为2048 使用HMAC-SHA512作为伪随机数生成函数 输出为 512位的种子 种子用于生成BIP 32中描述的确定性钱包（HD Wallet） 由于seed的生成完全独立于mnemonic的生成，这使得代码非常简洁。并且对助记词没有任何限制，用户可以实现自己的单词表，甚至是整个助记词的生成 虽然可以使用其他算法生成的助记符，但不建议这样做，并且APP中必须使用助记词表计算助记词的校验和，如果无效则应该提示用户。 注：错误的passphrase虽然也能生成有效的seed，并且生成钱包，但只有正确的passphrase生成的seed，才能获取到拥有财产的钱包]]></content>
      <tags>
        <tag>区块链</tag>
        <tag>BIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scala中的函数]]></title>
    <url>%2F2018%2F07%2F23%2Fscala%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[在各类blog及scala书籍中看到的关于函数最多的一句话是 函数是一等公民 可以看出函数在scala中举足轻重的地位，因此很有必要去全面的掌握它 scala函数基础定义函数 匿名函数 12scala&gt; (x: Int) =&gt; x + 1res0: Int =&gt; Int = $$Lambda$1026/1792711692@7412ed6b 固定写法：左边是参数列表，中间符号=&gt;，右边是函数体匿名函数无函数名，也无需给出函数的结果类型 函数字面量 123scala&gt; val f = (x: Int) =&gt; x + 1scala&gt; f(10)res0: Int = 11 其中表达式有半部分为一个匿名函数，函数作为一个变量(或不变量)，用变量名+参数表方式调用，与普通方法的调用几乎相同。 需要注意的是函数字面量声明函数时不需要写出函数的返回值类型，函数体的最后一条表达式的结果会作为返回值返回 函数值函数字面量与函数值的关系就像类与对象的关系。函数字面量其实就是一个实现了trait Function*的函数类，在运行时实例化了一个函数类，这个实例就是函数值 函数的本质scala不像java有基本类型与引用类型之分，scala中一切皆对象，包括函数也是对象。scala中定义了一系列trait，Function0 - Function22，其中0-22表示参数的个数(至于为什么是到22，理论上讲程序中不会出现多于22个参数的函数)。而函数正是Function的实例。如val f = (x: Int) =&gt; x + 1其实就是Function1的实例。下面看下Function的源码，以Function3为例123456789101112131415161718192021222324252627/** A function of 3 parameters. * */trait Function3[-T1, -T2, -T3, +R] extends AnyRef &#123; self =&gt; /** Apply the body of this function to the arguments. * @return the result of function application. */ def apply(v1: T1, v2: T2, v3: T3): R /** Creates a curried version of this function. * * @return a function `f` such that `f(x1)(x2)(x3) == apply(x1, x2, x3)` */ @annotation.unspecialized def curried: T1 =&gt; T2 =&gt; T3 =&gt; R = &#123; (x1: T1) =&gt; (x2: T2) =&gt; (x3: T3) =&gt; apply(x1, x2, x3) &#125; /** Creates a tupled version of this function: instead of 3 arguments, * it accepts a single [[scala.Tuple3]] argument. * * @return a function `f` such that `f((x1, x2, x3)) == f(Tuple3(x1, x2, x3)) == apply(x1, x2, x3)` */ @annotation.unspecialized def tupled: Tuple3[T1, T2, T3] =&gt; R = &#123; case Tuple3(x1, x2, x3) =&gt; apply(x1, x2, x3) &#125; override def toString() = "&lt;function3&gt;"&#125; 可以看到其中有一个apply方法(先忽略其他方法)，接受三个泛型参数，所以当我们调用f(1)时，其实是调用了Function1实例的apply方法。 函数与方法在学习过程中，还有一点很困扰，就是我们在类中用def定义的是不是函数，如果不是函数，它又是什么，跟函数又有什么区别呢？首先呢使用def 关键字定义的是方法，不是函数，虽然在实际应用中几乎没有差别，但还是需要了解两者的不同的 方法 定义在类中，作为某个对象的成员方法，使用def关键字定义12scala&gt; def a(x: Int):Int = x + 1a: (x: Int)Int 两者的区别 方法使用def关键字定义，而函数不用(函数使用val/var或干脆匿名) 方法是类的一部分，函数是对象可以赋值给一个val/var 函数作为对象可以像任何其他数据类型一样被传递和操作，而方法不行，如果想要传递方法，则需要把方法转换为函数 定义方法时，如果没有参数，则参数表可以省略不写(即方法名后不写())，而函数不行 定义函数时参数列表后不能声明结果类型，如下面的写法会编译错误1234scala&gt; f(x: Int):Int =&gt; x + 1&lt;console&gt;:1: error: ';' expected but '=&gt;' found. f(x: Int):Int =&gt; x + 1 ^ 两者的转换 第一种情况，方法直接转为函数不能将方法直接声明为一个val/var，如下面的写法会编译错误 123456scala&gt; def m(x: Int):Int = x + 1scala&gt; val f = m&lt;console&gt;:12: error: missing argument list for method mUnapplied methods are only converted to functions when a function type is expected.You can make this conversion explicit by writing `m _` or `m(_)` instead of `m`. val f = m 正确写法 123scala&gt; def m(x: Int):Int = x + 1scala&gt; val f = m _f: Int =&gt; Int = $$Lambda$1069/727861082@4990b335 这个转换的其实是使用了部分应用(Partial Applied Function)，下面将会讲到 第二种情况，需要函数的地方使用方法这种情况下不需要使用下划线，方法会被自动转换为函数，称之为eta转换。关于eta-expansion与eta-conversion的解释可以参考王宏江-scala中的eta-conversion与王宏江-再谈eta-conversion与eta-expansion scala函数进阶高阶函数引用维基百科中高阶函数的定义 在数学和计算机科学中，高阶函数是至少满足下列一个条件的函数： 接受一个或多个函数作为输入 输出一个函数 定义应该很容易理解，也就是函数可以接受另一个函数作为参数，或者函数的结果类型为函数类型。 第一种：如数学中的函数f(x) = x + 1， g(x) = x * 2，则f(g(x)) = (x * 2) + 1, 即为高阶函数。用代码实现即为 12def g(x: Int) = x * 2def f(x: Int, g: Int =&gt; Int) = g(x) + 1 第二种：结果类型为函数类型 1234def g(x: Int):(Int =&gt; Int) = &#123; val k = x * 2 (y: Int) =&gt; y + k + 1&#125; 函数的部分应用先看下代码如何实现函数的部分应用吧1234567891011121314scala&gt; def sum(x: Int, y: Int, z: Int) = x + y + zsum: (x: Int, y: Int, z: Int)Intscala&gt; val a = sum _a: (Int, Int, Int) =&gt; Int = $$Lambda$1055/565627330@309cedb6scala&gt; a(1,2,3)res0: Int = 6scala&gt; val b = sum(1, _: Int, _: Int)b: (Int, Int) =&gt; Int = $$Lambda$1060/605472344@6d5f4900scala&gt; b(2,3)res1: Int = 6 上面代码中出现了两种写法 写法一val a = sum _这行代码表示sum方法的三个参数都为给出，整个参数表都用占位符_代替，所以这行代码的效果其实就是讲方法sum转换为了函数a。与之相同的写法还有val a = sum(_) 写法二val b = sum(1, _: Int, _: Int)这行代码表示，已知三个参数中的x，y和z未给出，用占位符_代替，最后返回一个包含了两个参数的函数b 部分应用从数学角度理解比较容易，如上面例子中的sum，其实对应于数学中的sum(x,y,z) = x + y + z，这是一个三元函数(既有三个未知数)，而写法二对sum的部分应用，相当于我们现在得知x = 1，则带入函数得sum(y,z) = 1 + y + z，也就是函数f消去了未知元x。 整体来看函数的部分应用其实就是数学中的消元。 而写法是对未消去任何参数的一种简写 函数的柯里化在scala中函数函数可以有多个参数列表，而函数柯里化就是将函数的多参数列表转换为多个多参数列表。写法如下12345678scala&gt; def sum(x: Int, y: Int) = x + ysum: (x: Int, y: Int)Intscala&gt; val a = sum _a: (Int, Int) =&gt; Int = $$Lambda$1075/571435580@5eb041b5scala&gt; val b = a.curriedb: Int =&gt; (Int =&gt; Int) = scala.Function2$$Lambda$1076/1263872787@524dd373 柯里化是通过调用函数对象的curried方法实现的。也就是说调用的是Function*中的curried方法(Function2-Function22拥有curried方法，Function0及Function1没有，因为无参函数和但参函数不需要也不能柯里化)，以Function2为例，我们看下源码的实现1234567trait Function2[-T1, -T2, +R] extends AnyRef &#123; self =&gt; ... @annotation.unspecialized def curried: T1 =&gt; T2 =&gt; R = &#123; (x1: T1) =&gt; (x2: T2) =&gt; apply(x1, x2) &#125; ...&#125; curried的实现是将一个多参函数转换为一个单参函数的函数链，对于上面的例子来说就是把sum(x,y)转换成了sum(x)(y)，sum(1)(2)也就是对两个单参函数的依次调用，而sum(1)或者sum(2)其实相当于对sum函数的部分应用，返回值是一个单参函数 闭包引用别人blog中对闭包的定义 闭包是一个函数，返回值依赖于声明在函数外部的一个或多个变量。 示例12345scala&gt; var more = 1more: Int = 1scala&gt; val add = (i: Int) =&gt; i + moreadd: Int =&gt; Int = $$Lambda$1045/640294829@6be6931f 上面例子中add函数的计算依赖于自由变量more，也就是闭包了。闭包很像函数字面量，不同的是，闭包运算的过程不只依赖于输入参数，还需要依赖函数之外的一个或多个自由变量。 关于闭包的详细解释可以参考知乎-什么是闭包，引用博文中的总结 最简洁、直击要害的回答，我能想到的分别有这么三句（版权属于 ： 闭包是一个有状态（不消失的私有数据）的函数。 闭包是一个有记忆的函数。 闭包相当于一个只有一个方法的紧凑对象（a compact object）。 上面这三句话是等价的 嵌套函数scala允许在函数内部定义函数，称之为局部函数。它的作用域仅限于外部函数，其他位置无法访问到内部函数，可以达到控制访问的效果示例1234val f = (x:Int) =&gt; &#123; val innerAdd = (i: Int) =&gt; i + 1 innerAdd(x) + 1&#125; 写在最后关于scala中的函数，就先写这么多吧，等到后面开发应用到其他的知识，在作补充。关于函数的部分应用和柯里化的实际意义，在scala函数式编程那篇里写出来，这里就不写了]]></content>
      <categories>
        <category>scala</category>
      </categories>
      <tags>
        <tag>scala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scala函数式编程]]></title>
    <url>%2F2018%2F07%2F21%2Fscala%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[从java转向scala已经有一段时间了，虽然平时写代码问题不大，但是因为面向对象编程已经根深蒂固了，一直对函数式编程理解不是很到位，scala虽然是多范式编程语言，但是官方还是鼓励开发者使用函数式编程的，所以很有必要仔细学习并记录一下 什么是函数式函数式编程，不是某一种语言的特性，而是诸多编程思想(如命令式，面向对象等)中的一种。对于它的解释，引用王宏江-Scala中的函数式特性中的一段话 图灵机，以及冯诺依曼对它的实现（冯诺依曼体系），从风格上被归为“命令式”，它的运算过程可以看作不断地修改内存来反映运算的结果，即用命令修改状态；而阿隆佐邱奇提出的 Lambda 演算，则是通过连续的运算（基于函数）得到最终结果。基于Lambda演算的被归为函数式，在众多的函数式编程语言里，Scala的血缘继承自ML 和Haskell 最多。关于ML有本非常好的书《ML for the Working Programmer》，这本书里面提到:“函数式程序是跟值打交道的，而不是跟状态打交道的。它们的工具是表达式，而不是命令。” 表达式上面引文里，函数式程序的工具是表达式，那么什么是表达式呢？表达式可以简单理解为有返回值的语句。在scala中只有表达式，因为在scala中任何语句都有返回值，而在java中则不是。如赋值语句在scala中是有返回值的，返回类型为Unit，而在java中赋值语句没有返回值示例12345scala&gt; var b = 1b: Int = 1scala&gt; val a = b = 3a: Unit = () 变量b被重新赋值为3，赋值的结果类型为Unit，并且赋值给了a 个人理解函数式编程就是把计算机中的运算抽象为数学中的运算，程序中的函数和方法抽象为数学中的函数。如1234567def f(x: Int):Int = &#123; 3X + 1&#125;对应于数学中的f(X) = 3X + 1 函数的参数即为数学函数中的未知数(x或y等等)，整个运算过程封装在函数体中，并且不需要依赖除了参数外的其他数据，运算完成后返回运算的结果。 对于复杂的运算，抽象为多个函数的嵌套调用，整个运算的过程都是围绕函数进行的，摒弃了命令式编程中对状态的依赖，这也是为什么scala鼓励我们使用val不变量，而尽量少使用var变量 最终整个应用程序都是由一个一个的函数组成 为了支持函数式编程，scala中提供了很多函数特性，这些特性在scala中的函数那篇blog里，简单罗列下 引入了与其他类型地位平等的函数类型，函数可传递，可作为返回值 对高阶函数的支持 函数的部分应用 函数柯里化 函数嵌套 闭包 函数式编程的特性关于函数式编程的特性可以参考阮一峰-函数式编程初探]]></content>
      <categories>
        <category>scala</category>
      </categories>
      <tags>
        <tag>scala</tag>
        <tag>函数式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scala学习资料整理]]></title>
    <url>%2F2018%2F07%2F21%2Fscala%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[基础twitter scala school Scala课堂是Twitter启动的一系列讲座，用来帮助有经验的工程师成为高效的Scala 程序员twitter - Effective Scala Twitter的Scala最佳实践 优质blog王宏江scala系列**李浩毅blog 集合Scala中的集合Why scala.collection.Traversable Is Bad Design Scala Collection的性能(李浩毅blog的译文) 零散Scala中的下划线 持续更新中…]]></content>
      <categories>
        <category>scala</category>
      </categories>
      <tags>
        <tag>scala</tag>
      </tags>
  </entry>
</search>
