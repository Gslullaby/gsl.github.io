<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Gsl&#39;s blog</title>
  
  <subtitle>静待花开</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hcendless.ink/"/>
  <updated>2020-07-31T12:40:03.999Z</updated>
  <id>https://hcendless.ink/</id>
  
  <author>
    <name>何从</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Gradle构建的生命周期</title>
    <link href="https://hcendless.ink/2020/07/20/Gradle-build-lifecycle/"/>
    <id>https://hcendless.ink/2020/07/20/Gradle-build-lifecycle/</id>
    <published>2020-07-20T02:33:30.000Z</published>
    <updated>2020-07-31T12:40:03.999Z</updated>
    
    <content type="html"><![CDATA[<p>我们之前说过，Gradle的核心是一种基于依赖的编程语言。按照Gradle的术语来说，这意味着你可以定义一系列任务以及它们之间的依赖关系。Gradle会保证这些任务按照他们的依赖关系顺序执行，并且每个任务只会执行一次。这些任务一起构成了一个有向无环图（DAG）。某些构建工具会在构建任务执行阶段，组建依赖图。但是Gradle是在任务执行之前组建出完整的依赖图的。这正是Gradle的核心所在，使得许多不可能的事情成为了可能。    </p><p>由于构建脚本是用于配置依赖图的。因此严格意义上说，构建脚本应该称为构建配置脚本</p><h2 id="构建阶段"><a href="#构建阶段" class="headerlink" title="构建阶段"></a>构建阶段</h2><p>Gradle构建有三个不同的阶段</p><ul><li><p>初始换阶段（Initialization）</p><p>  Gradle支持单/多项目构建。在初始化阶段，Gradle会确定哪些项目要参与到构建中，并且为每个参与构建的项目创建一个Project实例</p></li><li><p>配置阶段（Configuration）   </p><p>  该阶段对Project实例进行配置。即每个参与构建的项目的构建脚本都会被执行</p></li><li><p>执行阶段（Execution）   </p><p>  配置阶段中Gradle创建并配置了一系列任务，最终输出一个任务图（DAG），执行阶段中Gradle会先确定一个DAG的待执行子任务集。子任务集是由gradle命令参数传入的任务名以及当前所在目录确定的。确定了子任务集后，Gradle会按顺序执行其中的每一个任务</p></li></ul><h2 id="Settings-gradle文件"><a href="#Settings-gradle文件" class="headerlink" title="Settings.gradle文件"></a>Settings.gradle文件</h2><p>除了构建脚本（build.gradle）文件，Gradle还定义了一个settings脚本文件。settings文件由Gradle通过命名约定确定。该文件的默认名为settings.gradle。在后续章节中会解释Gradle是如何查找settings文件的。<br>settings脚本在初始化阶段执行。多项目构建必须定义一个settings.gradle文件，文件路径为多项目的根项目目录。之所以该脚本文件是必需的，是因为该脚本定义了那些任务会参与到构建中。对于单项目构建，可以不定义该脚本文件。该文件中，除了定义参与项目外，可能还需要添加一些依赖库到构建脚本的classpath中。下面先来看一个单项目构建的例子    </p><p><em>Example 1. 单项目构建</em> </p><blockquote><p><strong>settings.gradle</strong></p></blockquote> <figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print <span class="string">'This is executed during the initialization phase.'</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>build.gradle</strong></p></blockquote> <figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">println <span class="string">'This is executed during the configuration phase.'</span></span><br><span class="line"></span><br><span class="line">task configured &#123;</span><br><span class="line">   println <span class="string">'This is also executed during the configuration phase.'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task test &#123;</span><br><span class="line">   doLast &#123;</span><br><span class="line">       println <span class="string">'This is executed during the execution phase.'</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task testBoth &#123;</span><br><span class="line">   doFirst &#123;</span><br><span class="line">       println <span class="string">'This is executed first during the execution phase.'</span></span><br><span class="line">   &#125;</span><br><span class="line">   doLast &#123;</span><br><span class="line">       println <span class="string">'This is executed last during the execution phase.'</span></span><br><span class="line">   &#125;</span><br><span class="line">   println <span class="string">'This is executed during the configuration phase as well.'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="命令-gradle-test-testboth-的输出"><a href="#命令-gradle-test-testboth-的输出" class="headerlink" title="命令 gradle test testboth 的输出"></a>命令 <code>gradle test testboth</code> 的输出</h4><blockquote></blockquote><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt; gradle test testBoth   </span><br><span class="line">This is executed during the initialization phase.</span><br><span class="line"> </span><br><span class="line">Configure <span class="string">project :</span>    </span><br><span class="line">This is executed during the configuration phase.    </span><br><span class="line">This is also executed during the configuration phase.    </span><br><span class="line">This is executed during the configuration phase <span class="keyword">as</span> well.</span><br><span class="line"></span><br><span class="line"><span class="string">Task :</span>test   </span><br><span class="line">This is executed during the execution phase.</span><br><span class="line"> </span><br><span class="line"><span class="string">Task :</span>testBoth      </span><br><span class="line">This is executed first during the execution phase.   </span><br><span class="line">This is executed last during the execution phase.</span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL <span class="keyword">in</span> <span class="number">0</span>s   </span><br><span class="line"><span class="number">2</span> actionable <span class="string">tasks:</span> <span class="number">2</span> executed</span><br></pre></td></tr></table></figure><p>对于build.gradle来说，其中属性的访问以及方法的调用都是委托给project对象完成的。同样的，对于settings.gradle来说是委托给Settings对象完成的。查看API文档中Settings类以了解更多信息</p><h2 id="多项目构建"><a href="#多项目构建" class="headerlink" title="多项目构建"></a>多项目构建</h2><p>所谓多项目构建，即为一次Gradle执行中会构建多个项目的构建。我们必须在settings脚本中声明参与构建的项目。在专门介绍此主题的一章中，有更多关于多项目生成的内容要说(请参见多项目构建)</p><h3 id="项目位置"><a href="#项目位置" class="headerlink" title="项目位置"></a><strong>项目位置</strong></h3><p>多项目构建总是可以由一个单根树表示。树中的每个元素代表一个项目。每个项目都有一个路径，用于表示该项目在构建树中的位置。大多数情况下，项目的路径即为该项目在文件系统中的真实物理位置。然而，该路径是可配置的。项目树在settings.gradle脚本文件中创建。默认情况下会假定settings.gradle文件目录在根项目目录中。可以在settigns脚本文件中重新定义根项目的目录</p><h3 id="构建项目树"><a href="#构建项目树" class="headerlink" title="构建项目树"></a><strong>构建项目树</strong></h3><p>在settings文件中，可以使用一系列方法来构建项目树。层次化和扁平化的物理布局都得到了支持。</p><h4 id="层次化布局"><a href="#层次化布局" class="headerlink" title="层次化布局"></a>层次化布局</h4><p><em>Example 2. 层次化布局</em></p><blockquote><p><strong>settings.gradle</strong></p></blockquote> <figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include <span class="string">'project1'</span>, <span class="string">'project2:child'</span>, <span class="string">'project3:child1'</span></span><br></pre></td></tr></table></figure><p><code>include</code> 方法以project路径作为参数。假定project路径即为物理文件系统的相对路径。例如，路径’services:api’默认情况下会映射到’services/api’文件夹（相当于项目根目录）。路径中我们仅需要给出项目树的叶子节点即可。例如路径’service:hotels:api’将会创建三个项目：’services’，’service:hotels’以及’service:hotels:api’。更多关于如何使用project路径，请参阅DSL文档中的<code>Settings.include(java.lang.String[])</code>方法    </p><h4 id="扁平化布局"><a href="#扁平化布局" class="headerlink" title="扁平化布局"></a>扁平化布局</h4><p><em>Example 3. 扁平化布局</em></p><blockquote><p><strong>settings.gradle</strong></p></blockquote> <figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">includeFlat <span class="string">'project3'</span>, <span class="string">'project4'</span></span><br></pre></td></tr></table></figure><p><code>includeFlat</code>方法以目录名作为参数。这些目录必须为根项目目录的同级目录。这些目录的位置被视为多项目树中根项目的子项目。</p><h3 id="修改项目树中的元素"><a href="#修改项目树中的元素" class="headerlink" title="修改项目树中的元素"></a><strong>修改项目树中的元素</strong></h3><p>在设置文件中创建的多项目树由所谓的项目描述符组成。你可以随时在settings文件中修改这些描述符。可以通过下面的方式访问描述符：<br><em>Example 4.访问项目树的元素</em></p><blockquote><p><strong>settings.gradle</strong></p></blockquote> <figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">println rootProject.name</span><br><span class="line">println project(<span class="string">':projectA'</span>).name</span><br></pre></td></tr></table></figure><p>使用project描述符可以修改project的名字、目录以及项目对应的build文件</p><p><em>Example 5.修改项目树中的元素</em></p><blockquote><p><strong>settings.gradle</strong></p></blockquote> <figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rootProject.name = <span class="string">'main'</span></span><br><span class="line">project(<span class="string">':projectA'</span>).projectDir = <span class="keyword">new</span> File(settingsDir, <span class="string">'../my-project-a'</span>)</span><br><span class="line">project(<span class="string">':projectA'</span>).buildFileName = <span class="string">'projectA.gradle'</span></span><br></pre></td></tr></table></figure><p>查看API文档中的<code>ProjectDescriptor</code>类以获取更多信息</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>Gradle是如何知道当前进行单项目构建还是多项目构建的呢？如果从一个包含settings文件的目录触发多项目构建，那么一切都很清楚。但是Gradle允许从任何一个参与构建的子项目触发构建。如果从一个不包含settings.gradle文件的子项目中触发构建，则Gradle会按照以下方式查找settings.gradle文件    </p><ul><li>从master目录下查找，master目录与当前目录在同层级</li><li>如果没找到，则从其父目录中查找</li><li>如果还没找到，则进行单项目构建</li><li>如果找到了一个settings.gradle文件，Gradle首先会检查当前项目是否存在于settings.gradle文件中定义的多项目层级中。如果不是，则将构建作为单项目构建执行。否则，将执行多项目构建</li></ul><p>那么此种行为的目的是什么呢？这是因为Gradle需要确定当前所在的project是否是多项目构建的子项目。如果是，则构建当前子项目以及其所依赖的项目，但是Gradle会为整个多项目构建创建构建配置。如果当前项目有settings.gradle文件，则构建会以如下方式执行</p><ul><li>如果settings.gradle文件未定义多项目层级，则进行单项目构建</li><li>否则进行多项目构建</li></ul><p>对于settings.gradle文件的自动搜索仅适用于物理上层次化或扁平化布局的多项目构建。对于扁平化布局，则必须遵从上述的（”master”）命名约定。Gradle支持多项目构建的任意物理布局，但是对于这种任意布局，需要从settings.gradle所属目录执行构建。关于如何从根目录执行部分构建，请参阅按任务的绝对路径运行任务</p><p>Gradle为每个参与构建的项目创建一个Project对象。对于多项目构建，即为Settings对象中指定的Project以及一个root Project。Project对象的name即为project顶层目录的name，每个Project都有一个父Project（root Project除外）。每个Project都可能拥有子Project</p><h2 id="单项目构建的配置与执行"><a href="#单项目构建的配置与执行" class="headerlink" title="单项目构建的配置与执行"></a>单项目构建的配置与执行</h2><p>对于单项目构建，其初始化阶段之后的工作流是十分简单的。构建脚本按照初始化阶段创建的Project对象执行。然后Gradle按照命令行传入的参数查找需要执行的任务。如果任务存在，则会按照所传入的顺序分别独立执行。多项目构建的配置与执行会在<em>Authoring Multi-Project Builds</em>中讨论</p><h2 id="响应构建脚本中的生命周期"><a href="#响应构建脚本中的生命周期" class="headerlink" title="响应构建脚本中的生命周期"></a>响应构建脚本中的生命周期</h2><p>构建过程中，构建脚本会收到构建的生命周期通知。剋以以两种方式接受通知：</p><ol><li>实现一个特殊的监听器接口</li><li>提供一个通知触发时执行的闭包</li></ol><p>下面的例子中使用了闭包的方式。关于如何使用监听器接口，请参阅API文档</p><h3 id="Project的评估"><a href="#Project的评估" class="headerlink" title="Project的评估"></a><strong>Project的评估</strong></h3><p>在Project评估的前后，我们均会立马收到一个通知。在构建脚本中所有的定义均已应用后，执行可以使用此特性做一些额外操作，如执行附加配置、添加自定义日志或性能分析等</p><p>下面例子中，为每个拥有hasTests属性且值为true的Project添加了一个test任务</p><p><em>Example 6.为拥有特定属性的project添加一个test任务</em></p><blockquote><p><strong>build.gradle</strong></p></blockquote> <figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    afterEvaluate &#123;</span><br><span class="line">        <span class="keyword">if</span> (project.hasTests) &#123;</span><br><span class="line">            println <span class="string">"Adding test task to $project"</span></span><br><span class="line">            project.task(<span class="string">'test'</span>) &#123;</span><br><span class="line">                doLast &#123;</span><br><span class="line">                    println <span class="string">"Running tests for $project"</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>projectA.gradle</strong></p></blockquote><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hasTest = <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="命令gradle-q-test的输出"><a href="#命令gradle-q-test的输出" class="headerlink" title="命令gradle -q test的输出"></a>命令<code>gradle -q test</code>的输出</h4><blockquote></blockquote><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; gradle -q test    </span><br><span class="line">Adding test task to project <span class="string">':projectA'</span>    </span><br><span class="line">Running tests <span class="keyword">for</span> project <span class="string">':projectA'</span></span><br></pre></td></tr></table></figure><p>本例调用了Project.afterEvalute()方法并传入一个闭包，该闭包在相应Project评估完成后执行</p><p>当然在任一Project评估完成后接受通知也是可以的。下面的例子增加了一些Project评估的日志。需要注意的是无论Project评估成功与否，均会收到afterProject通知</p><p><em>Example 7.在每个项目评估完成后都会收到的通知</em></p><blockquote><p><strong>build.gradle</strong></p></blockquote> <figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gradle.afterProject &#123;</span><br><span class="line">   <span class="keyword">if</span> (project.state.failure) &#123;</span><br><span class="line">       println <span class="string">"Evaluation of $project FAILED"</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       println <span class="string">"Evaluation of $project succeeded"</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="命令gradle-q-test的输出-1"><a href="#命令gradle-q-test的输出-1" class="headerlink" title="命令gradle -q test的输出"></a>命令<code>gradle -q test</code>的输出</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt; gradle -q test</span><br><span class="line">Evaluation of root project <span class="string">'buildProjectEvaluateEvents'</span> succeeded    </span><br><span class="line">Evaluation of project <span class="string">':projectA'</span> succeeded    </span><br><span class="line">Evaluation of project <span class="string">':projectB'</span> FAILED</span><br><span class="line"></span><br><span class="line"><span class="string">FAILURE:</span> Build failed with an exception.</span><br><span class="line"></span><br><span class="line">* <span class="string">Where:</span></span><br><span class="line">Build file <span class="string">'/home/user/gradle/samples/projectB.gradle'</span> <span class="string">line:</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">* What went <span class="string">wrong:</span></span><br><span class="line">A problem occurred evaluating project <span class="string">':projectB'</span>.</span><br><span class="line">broken</span><br><span class="line"></span><br><span class="line">* <span class="string">Try:</span></span><br><span class="line">Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.</span><br><span class="line"></span><br><span class="line">* Get more help at <span class="string">https:</span><span class="comment">//help.gradle.org</span></span><br><span class="line"></span><br><span class="line"> BUILD FAILED <span class="keyword">in</span> <span class="number">0</span>s</span><br></pre></td></tr></table></figure><p>也可以通过给Gradle添加一个ProjectEvaluationListener已接受通知事件</p><h3 id="任务的创建"><a href="#任务的创建" class="headerlink" title="任务的创建"></a><strong>任务的创建</strong></h3><p>在一个task被添加到project后，也会立马收到一个通知。在task可用之前，可以为其设置一些默认值或其他操作</p><p>下面例子在每个task创建之后，为其设置了<code>srcDir</code>属性</p><p><em>Example 8.为所有任务设置特性属性</em></p><blockquote><p><strong>build.gradle</strong></p></blockquote> <figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tasks.whenTaskAdded &#123; task -&gt;</span><br><span class="line">   task.ext.srcDir = <span class="string">'src/main/java'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task a</span><br><span class="line"></span><br><span class="line">println <span class="string">"source dir is $a.srcDir"</span></span><br></pre></td></tr></table></figure><h4 id="命令gradle-q-a的输出"><a href="#命令gradle-q-a的输出" class="headerlink" title="命令gradle -q a的输出"></a>命令<code>gradle -q a</code>的输出</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; gradle -q a   </span><br><span class="line">source dir is src<span class="regexp">/main/</span>java</span><br></pre></td></tr></table></figure><p>也可以通过向TaskContainer添加一个Action来接受这些事件</p><h3 id="任务图的组建"><a href="#任务图的组建" class="headerlink" title="任务图的组建"></a><strong>任务图的组建</strong></h3><p>任务图组建完成后，也会立即收到一个通知   </p><p>通过向TaskExecutionGraph添加一个TaskExecutionGraphListener以接受这些事件</p><h3 id="任务的执行"><a href="#任务的执行" class="headerlink" title="任务的执行"></a><strong>任务的执行</strong></h3><p>任一任务执行的前后我们都会立即收到通知</p><p>下面例子在每个任务执行的前后输出了日志。注意无论任务执行成功与否均会收到<code>afterTask</code>通知</p><p><em>Example 9.记录每个任务执行的开始与结束</em></p><blockquote><p><strong>build.gradle</strong></p></blockquote> <figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">task ok</span><br><span class="line"></span><br><span class="line">task broken(<span class="string">dependsOn:</span> ok) &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">'broken'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gradle.taskGraph.beforeTask &#123; Task task -&gt;</span><br><span class="line">   println <span class="string">"executing $task ..."</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gradle.taskGraph.afterTask &#123; Task task, TaskState state -&gt;</span><br><span class="line">    <span class="keyword">if</span> (state.failure) &#123;</span><br><span class="line">        println <span class="string">"FAILED"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        println <span class="string">"done"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="命令gradle-q-broken的输出"><a href="#命令gradle-q-broken的输出" class="headerlink" title="命令gradle -q broken的输出"></a>命令<code>gradle -q broken</code>的输出</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt; gradle -q broken    </span><br><span class="line">executing task <span class="string">':ok'</span> ...    </span><br><span class="line">done   </span><br><span class="line">executing task <span class="string">':broken'</span> ...   </span><br><span class="line">FAILED</span><br><span class="line"></span><br><span class="line"><span class="string">FAILURE:</span> Build failed with an exception.</span><br><span class="line"></span><br><span class="line">* <span class="string">Where:</span>   </span><br><span class="line">Build file <span class="string">'/home/user/gradle/samples/build.gradle'</span> <span class="string">line:</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line">* What went <span class="string">wrong:</span>   </span><br><span class="line">Execution failed <span class="keyword">for</span> task <span class="string">':broken'</span>.   </span><br><span class="line">&gt; broken   </span><br><span class="line"></span><br><span class="line">* <span class="string">Try:</span>    </span><br><span class="line">Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.</span><br><span class="line"></span><br><span class="line">* Get more help at <span class="string">https:</span><span class="comment">//help.gradle.org</span></span><br><span class="line"></span><br><span class="line">BUILD FAILED <span class="keyword">in</span> <span class="number">0</span>s</span><br></pre></td></tr></table></figure><p>也可以通过向TaskExecutionGraph添加TaskExecutionListener来接受这些事件</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们之前说过，Gradle的核心是一种基于依赖的编程语言。按照Gradle的术语来说，这意味着你可以定义一系列任务以及它们之间的依赖关系。Gradle会保证这些任务按照他们的依赖关系顺序执行，并且每个任务只会执行一次。这些任务一起构成了一个有向无环图（DAG）。某些构建工具
      
    
    </summary>
    
    
      <category term="gradle" scheme="https://hcendless.ink/tags/gradle/"/>
    
  </entry>
  
  <entry>
    <title>Gradle是什么</title>
    <link href="https://hcendless.ink/2020/07/17/What-is-Gradle/"/>
    <id>https://hcendless.ink/2020/07/17/What-is-Gradle/</id>
    <published>2020-07-17T06:00:31.000Z</published>
    <updated>2020-07-17T10:06:11.405Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Gradle是一款开源的自动化构建工具，它设计的灵活性使得它几乎能构建任何类型的软件。下面列出了一些它的重要特性    </p><ul><li><p>高效率</p><p>  Gradle仅仅去执行那些输入或输出发生了改变的task，避免执行不必要的task。也可以使用构建缓存复用之前task的output，甚至可以跨设备使用构建缓存（多设备共享构建缓存）<br>  Gradle的实现中有许多其他方面的优化，开发组也在持续改进Gradle的运行效率</p></li><li><p>基于JVM</p><p>  Gradle是运行在JVM之上了（因此没有了跨平台的问题），所以用户需要安装JDK才能使用。对熟悉Java平台的用户来说这是一项福利，因为可以使用标准Java Apis实现构建逻辑，如自定义各种任务类型和插件<br>  虽然Gradle基于JVM，但这并不意味着Gradle只能构建java项目，它甚至可以用来构建native项目</p></li><li><p>约定</p><p>  Gradle借鉴了Maven的经验，通过实现约定使常见类型的项目(如Java项目)变得更容易构建。 使用适当的插件，您可以很容易地为许多项目生成精简的构建脚本。 但是这些约定并不会不限制你：Gradle允许你覆盖它们，添加自己的任务，并对你的基于约定的构建进行许多其他定制。</p></li><li><p>良好的可扩展性</p><p>  你可以很容易地扩展Gradle以提供自己的任务类型，甚至构建模型。 有关这方面的示例，请参阅Android构建支持：它添加了许多新的构建概念，如风格和构建类型。</p></li><li><p>主流IDE均支持Gradle</p><p>  许多主流的IDE均支持Gradle，如Android Studio，IntelliJ IDEA，Eclipse，NetBeans等</p></li><li><p>构建过程可视化</p><p>  构建过程中构建扫描器会生成大量的日志，这些日志可用于定位构建问题。并能很好的反应构建的性能问题。在你构建发生问题咨询别人时，可以将这些构建日志分享给他，以便于定位问题</p></li></ul><h2 id="关于Gradle你需要知道的五件事"><a href="#关于Gradle你需要知道的五件事" class="headerlink" title="关于Gradle你需要知道的五件事"></a>关于Gradle你需要知道的五件事</h2><p>Gradle是一款灵活且强大的构建工具，但是第一次使用它时，你可能会觉得很难上手。当你理解了以下核心原则，你会觉得Gradle变得简单很多，并且你会在不知不觉中熟练使用它</p><h4 id="1-Gradle是一款通用构建工具"><a href="#1-Gradle是一款通用构建工具" class="headerlink" title="1. Gradle是一款通用构建工具"></a>1. Gradle是一款通用构建工具</h4><p>Gradle可用于构建任何软件，因为它对你尝试构建的内容或应该如何构建几乎没有任何假设。一个最值得注意的限制是，依赖管理模块目前只支持Maven、Ivy的兼容仓库以及文件系统    </p><p>这并不意味着需要做大量的工作才能创建一个构建。 Gradle通过插件添加了一层约定和预构建的功能，使得构建常见类型的项目(比如Java库)变得很容易。 你甚至可以创建和发布自定义插件来封装你自己的约定和构建功能。</p><h4 id="2-核心的model基于task"><a href="#2-核心的model基于task" class="headerlink" title="2. 核心的model基于task"></a>2. 核心的model基于task</h4><p>Gradle将models构建成一个task（工作的基本单元）的有向无环图（DAGs - Directed Acyclic Graphs）。意思是说，构建本质上配置了一组task，并根据他们的依赖关系将它们链接在一起，从而构成了一个有向无环图。一旦任务图创建完成，Gradle就确定了哪些任务需要以什么顺序执行，然后就调度执行这些任务</p><p>下面的图为任务图示例，第一幅为抽象任务图，第二幅为具体任务图。任务间的依赖关系使用箭头来表示</p><img src="/2020/07/17/What-is-Gradle/task-dag-examples.png" title="主密钥生成"><p>几乎所有的构建过程都可以通过这种方式建模为任务图，这也是Gradle拥有如此灵活性的原因之一。任务既可以通过插件定义，也可以通过你自己的构建脚本定义，任务通过其依赖机制链接在一起。</p><p>任务的组成:</p><ul><li>操作 - 执行某些操作，如文件复制或编译源代码等</li><li>输入 - 操作需要用到的值、文件或目录等</li><li>输出 - 操作修改或生成的文件或目录等</li></ul><p>实际上，任务的组成完全取决于task需要执行什么操作。某些task甚至没有action，如标准的生命周期task（方便起见仅仅将多个任务整合在一起而存在）</p><p>另外需要注意的是：Gradle的增量构建支持是十分强大且可靠的，所以为了保持构建的高效运行，在不必要的情况下不要执行clean task</p><h4 id="Gradle有几个固定的构建阶段"><a href="#Gradle有几个固定的构建阶段" class="headerlink" title="Gradle有几个固定的构建阶段"></a>Gradle有几个固定的构建阶段</h4><p>理解Gradle分三个阶段评估和执行构建脚本是很重要的</p><ol><li><p>初始化阶段</p><p>为构建设置环境，决定那些project需要参与构建</p></li><li><p>配置阶段</p><p>构造并配置生成的task图，然后根据用户要运行的task确定需要运行哪些task，以及task运行的顺序</p></li><li><p>执行阶段</p><p>运行配置阶段结束时输出的任务</p></li></ol><p>以上这三个阶段组成了构建的生命周期<br>设计良好的构建脚本主要由声明性配置组成，而不是命令性逻辑。在配置阶段对配置项进行评估是很容易理解的。即便如此，很多构建有不少工作（经过评估后在执行阶段）需要做，如通过doLast和doFirst代码块。这一点很重要，因为在配置阶段评估的代码不会看到在执行阶段发生的更改   </p><p>配置阶段另一个非常重要的方面是，每次运行构建时都会对其中涉及的所有内容进行评估。这就是为什么最佳实践是避免在配置阶段做过多工作的原因， 构建扫描器可以帮助你识别这些热点，以及其他功能</p><h4 id="Gradle的扩展方式不止一种"><a href="#Gradle的扩展方式不止一种" class="headerlink" title="Gradle的扩展方式不止一种"></a>Gradle的扩展方式不止一种</h4><p>如果你只用Gradle内建bundle就能构建你的应用，那是极好的，但这几乎不可能。因为大多数构建都有一些特殊需求，这意味着你需要添加自定义构建逻辑  </p><p>Gradle提供了几种机制用以对其进行扩展</p><ul><li>自定义任务类型<br>当你需要执行的操作现有的构建任务满足不了，你可以实现一个你自己的任务类型。通常，最好将自定义任务类型的源文件放在buildSrc目录或打包在插件中。 然后，你就可以像使用Gradle提供的任何任务类型一样使用自定义的任务类型</li><li>自定义任务操作<br>你可以在一个任务的执行前后附加上自定义构建逻辑（通过使用Task.doFirst(),Task.doLast()方法）</li><li>为project和task添加额外属性<br>可以为project或task添加自己的属性，后续你可以在自己的自定义操作或其他任何构建逻辑中使用这些属性。额外属性甚至可以用于那些不是由你创建的task（如Gradle核心插件创建的task）</li><li>自定义约定<br>约定可以很大程度上简化构建，这样用户可以更容易理解并使用他们。 这可以在使用标准项目结构和命名约定的构建中看到，比如Java构建。 你可以编写自己的插件来提供约定-它们只需要为构建的相关方面配置默认值。</li><li>自定义model<br>Gradle允许你在任务、文件和依赖项配置之外的构建中引入新概念。你可以在大多数语言插件中看到这一点，他们将source sets的概念添加到构建中。对构建过程的适当建模可以极大的提高构建的易用性和效率</li></ul><h4 id="构建脚本按照Api进行操作"><a href="#构建脚本按照Api进行操作" class="headerlink" title="构建脚本按照Api进行操作"></a>构建脚本按照Api进行操作</h4><p>可以很容易将Gradle构建脚本视为可执行代码，因为他们本身就是可执行代码。实现细节：设计良好的构建脚本描述构建软件需要哪些步骤，而不是描述这些步骤如何完成工作，这是自定义任务类型及插件的职责</p><blockquote><p>有一种常见的误解，认为Gradle的强大和灵活性来自于它的构建脚本是代码这一事实。 这与事实大相径庭。 提供强大功能的是底层模型和API。 正如我们在最佳实践中建议的那样，你应该避免在构建脚本中放置太多(如果有的话)命令性逻辑。</p></blockquote><p>然而，在一种场景中，将构建脚本视为可执行代码是很有用的：理解构建脚本语法如何映射到Gradle API。API文档（由Javadocs和Groovy DSL Reference组成）列出了方法和属性，并引用了闭包和操作。这些在构建脚本上文中意味着什么呢？查看Groovy Build Script Primer了解该问题的答案，这样您就可以有效地使用API文档</p><blockquote><p>由于Gradle运行在JVM之上，所以构建脚本可以使用标准的Java API。Groovy构建脚本可以使用Groovy API，当然Kotlin构建脚本可以使用Kotlin API</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Gradle是一款开源的自动化构建工具，它设计的灵活性使得它几乎能构建任何类型的软件。下面列出了一些它的重要特性    &lt;/p&gt;
&lt;ul&gt;

      
    
    </summary>
    
    
      <category term="gradle" scheme="https://hcendless.ink/tags/gradle/"/>
    
  </entry>
  
  <entry>
    <title>转载--计算机语言协程的历史、现在和未来</title>
    <link href="https://hcendless.ink/2020/05/05/history-of-coroutine/"/>
    <id>https://hcendless.ink/2020/05/05/history-of-coroutine/</id>
    <published>2020-05-05T09:18:32.000Z</published>
    <updated>2020-07-31T12:40:17.632Z</updated>
    
    <content type="html"><![CDATA[<p>本文原发于《程序员》2014年11月刊。好文章备份一份</p><p>计算机科学是一门应用科学，几乎所有概念都是为了理解或解决实际问题而生的。协程 (Coroutine) 的出现也不例外。协程的概念，最早可以追溯到写作 COBOL 语言编译器中的技术难题。</p><h2 id="从磁带到协程"><a href="#从磁带到协程" class="headerlink" title="从磁带到协程"></a>从磁带到协程</h2><p>COBOL是最早的高级语言之一，编译器则是高级语言必不可少的一部分。现如今，我们对编译器的了解，已经到了可以把核心内容浓缩成一本教科书的程度。然而在二十世纪六十年代，如何写作高效的语言编译器还是绕不过的现实问题。例如，1960年夏天，D. E. Knuth就是利用开车横穿美国去加州理工读研究生的时间，对着<a href="https://www.cs.virginia.edu/brochure/images/manuals/b205/central/central.html" target="_blank" rel="noopener">Burroughs 205</a>机器指令集手写COBOL编译器。最早提出“协程”概念的Melvin Conway，也是从如何写一个只扫描一遍程序（one-pass）的COBOL编译器出发。众多的“高手”纷纷投入编译器开发，可见一门新科学发展之初也是筚路蓝缕。</p><p>以现代眼光来看，高级语言编译实际由多个步骤组合而成：词法解析、语法解析、语法树构建，以及优化和目标代码生成等。编译实质上就是从源程序出发，依次将这些步骤的输出作为下一步的输入，最终输出目标代码。在现代计算机上实现这种管道式的架构毫无困难：只需要依次运行，中间结果存为中间文件或放入内存即可。GCC和Clang编译器，以及<a href="http://www.antlr.org/" target="_blank" rel="noopener">ANTLR</a>构建的编译器，都遵循这种设计。</p><p>在Conway的设计里，词法和语法解析不再是独立运行的步骤，而是交织在一起。编译器的控制流在词法和语法解析之间来回切换：当词法模块读入足够多的token时，控制流交给语法分析；当语法分析消化完所有token后，控制流交给词法分析。词法和语法分别独立维护自身的运行状态。Conway构建的这种协同工作机制，需要参与者“让出（yield）”控制流时，记住自身状态，以便在控制流返回时能从上次让出的位置恢复（resume）执行。简言之，协程的全部精神就在于控制流的主动让出和恢复。我们熟悉的子过程调用可以看作在返回时让出控制流的一种特殊协程，其内部状态在返回时被丢弃了，因此不存在“恢复”这个操作。</p><p>以现在眼光来看，编译器的实现并非必需协程。然而，Conway用协程实现COBOL编译器在当时绝不是舍近求远。首先，从原理上，因为COBOL并不是<a href="https://en.wikipedia.org/wiki/LL_parser" target="_blank" rel="noopener">LL(1)</a>型语法，无法简单构建一个以词法分析为子过程的自动机。其次，当年计算机依赖于磁带存储设备，只支持顺序存储。也就是说，依次执行编译步骤并依靠中间文件通信的设计是不现实的，各步骤必须同步前进。正是这样的现实局限和设计需要，催生了协程的概念。</p><h2 id="自顶向下，无需协同"><a href="#自顶向下，无需协同" class="headerlink" title="自顶向下，无需协同"></a>自顶向下，无需协同</h2><p>虽然协程伴随着高级语言诞生，却没有能像子过程那样成为通用编程语言的基本元素。</p><p>从1963年首次提出到上世纪九十年代，我们在ALOGL、Pascal、C、FORTRAN等主流的命令式编程语言中都没有看到原生的协程支持。协程只稀疏地出现在Simula、Modular-2（Pascal升级版）和Smalltalk等相对小众的语言中。作为一个比子进程更加通用的概念，在实际编程中却没有取代子进程，不得不说出乎意外。但如果结合当时的程序设计思想看，又在意料之中：协程不符合那个时代所崇尚的“自顶向下”的程序设计思想，自然也就不会成为当时主流的命令式编程语言的一部分。</p><p>正如面向对象的语言是围绕面向对象的开发理念设计一样，命令式编程语言是围绕自顶向下的开发理念设计的。在这种理念的指导下，程序被切分为一个主程序和大大小小的子模块，每个子模块又可能调用更多子模块。C家族语言的main()函数就是这种自顶向下思想的体现。在这种理念指导下，各模块形成层次调用关系，而程序设计就是制作这些子过程。</p><p>在“自顶向下”这种层次化的理念下，具有鲜明层次的子过程调用成为软件系统最自然的组织方式，也是理所当然。相较之下，具有执行中让出和恢复功能的协程在这种架构下无用武之地。可以说，自顶向下的设计思想从一开始就排除了对协程的需求。其后的结构化编程思想，更进一步强化了“子过程调用作为唯一控制结构”的基本假设。在这样的指导思想下，协程没有成为当时编程语言的一等公民。</p><p>但作为一种易于理解的控制结构，协程的概念渗入到了软件设计的许多方面。在结构化编程思想一统天下之时，Knuth曾专门写过一篇<a href="http://c2.com/cgi/wiki?StructuredProgrammingWithGoToStatements" target="_blank" rel="noopener">《Structured Programming with GOTO》</a>来为GOTO语句辩护。在他列出的几条GOTO可以方便编程且不破坏程序结构的例子中，有一个（例子7b）就是用GOTO实现协程控制结构。相较之下，不用GOTO的“结构化”代码反而失去了良好的结构。当然，追求实际结果的工业界对于学界这场要不要剔除GOTO的争论并不感冒。当时许多语言都附带了不建议使用的GOTO语句，显得左右逢源。这方面一个最明显的例子就是Java——语言本身预留了goto关键字，而编译器却没提供任何支持，在这场争论中做足了中间派。</p><p>实践中，协程的思想频繁应用于任务调度和流处理。例如，Unix管道就可以看成是众多命令间的协同操作。当然，管道的现代实现都以pipe()系统调用和进程间的通信为基础，而非简单遵循协程的yield/resume语法。</p><p>许多协同式多任务操作系统，也可以看成协程运行系统。说到协同式多任务系统，一个常见的误区是认为协同式调度比抢占式调度“低级”，因为我们所熟悉的桌面操作系统，都是从协同式调度（如Windows 3.2、Mac OS 9等）过渡到抢占式多任务系统的。实际上，调度方式并无高下，完全取决于应用场景。抢占式系统允许操作系统剥夺进程执行权限，抢占控制流，因而天然适合服务器和图形操作系统，因为调度器可以优先保证对用户交互和网络事件的快速响应。当年Windows 95刚推出时，抢占式多任务就被作为一大卖点大加宣传。协同式调度则等到进程时间片用完或系统调用时转移执行权限，因此适合实时或分时等对运行时间有保障的系统。</p><p>另外，抢占式系统依赖于CPU的硬件支持。因为调度器需要“剥夺”进程的执行权，就意味着调度器需要运行在比普通进程高的权限上，否则任何“流氓（rogue）”进程都可以去剥夺其他进程了。只有CPU支持了执行权限后，抢占式调度才成为可能。x86系统从80386处理器开始引入Ring机制支持执行权限，这也是为何Windows 95和Linux其实只能运行在80386之后的x86处理器上的原因。而协同式多任务适用于那些没有处理器权限支持的场景，这些场景包括资源受限的嵌入式系统和实时系统。在这些系统中，程序均以协程的方式运行。调度器负责控制流的让出和恢复。通过协程的模型，无需硬件支持，我们就可以在一个“简陋”的处理器上实现多任务系统。许多常见的智能设备，如运动手环，受硬件所限，都采用协同调度架构。</p><h2 id="协程的复兴和现代形式"><a href="#协程的复兴和现代形式" class="headerlink" title="协程的复兴和现代形式"></a>协程的复兴和现代形式</h2><p>编程思想能否普及开来，很大程度上在于应用场景。协程没有能在自顶向下的世界里立足，却在动态语言世界中大放光彩，这里最显著的例子莫过于Python的迭代器和生成器。<br>回想一下在C的世界里，循环的标准写法是<br><code>for (i = 0; i &lt; n; ++i) { ... }</code><br>这行代码包含两个独立的逻辑：for循环控制了i的边界条件，++i控制了i的自增逻辑。这行代码适用于C世界里的数组即内存位移的范式，因此适合大多数访问场景。对于STL和复杂数据结构，因为往往只支持顺序访问，循环大多写成：<code>for (i = A.first(); i.hasNext(); i = i.next()) { ... }</code></p><p>这种设计抽象出了一个独立于数据结构的迭代器，专门负责数据结构上元素的访问顺序。迭代器把访问逻辑从数据结构中分离出来，是一个常用的设计模式（GoF 23个设计模式之一），我们在STL和Java Collection中也常常看到迭代器的身影。在适当的时候，我们可以更进一步引入一个语法糖，将循环写成：<code>for i in A.Iterator() {func(i)}</code></p><p>事实上，许多现代语言都支持类似的语法。这种语法抛弃了以i变量作为迭代指针的功能，要求迭代器自身能记住当前迭代位置，调用时返回下一个元素。读者不难看到，这就是我们在文章开始提到的语法分析器的架构。正因为如此，我们可以从协程的角度来理解迭代器：当控制流转换到迭代器时，迭代器负责生成和返回下一个元素。一旦准备就绪，迭代器就让出控制流。在Python中，这种特殊的迭代器实现又被成为生成器。以协程角度切入的好处在于设计大大精简。实际上，在Python中，生成器本身就是一个普通函数，和其他普通函数的唯一不同，在于它的返回语句是协程风格的yield。这里，yield一语双关，既是让出控制流，也是生成迭代器的返回值。</p><p>前文我们仅讨论了生成器最基本的特性。实际上，生成器的强大之处在于我们可以像Unix管道一样串联起来，组成所谓的生成器表达式。如果我们有一个可以生成1，2，3 …的生成器N，则square = (i *<em>2 for i in N)就是一个生成平方数的生成器表达式。注意这里圆括号语法和<a href="http://en.wikipedia.org/wiki/List_comprehension" target="_blank" rel="noopener">list comprehansion</a>方括号语法的区别，square = [i *</em>2 for i in N]是生成一个具体的列表。我们可以串联这些生成器表达式，最终的控制流会在这些串联的部分间转换，无需编写复杂的嵌套调用。当然，yield只是冰山的一角，现代的Python语言还充分利用了yield关键字构建<a href="https://www.python.org/dev/peps/pep-0380/" target="_blank" rel="noopener">yield from</a>语句、(yield)语法等，让我们毫无困难地将协程的思想融入到Python编程中，限于篇幅这里不再展开。</p><p>我们前面说过，协程的思想本质上就是控制流的主动让出和恢复机制。在现代语言中，可以实现协程思想的方法很多，这些实现间并无高下之分，所区别的就是是否适合应用场景。理解这一点，我们对于各种协程的分类，如半对称/对称协程、有栈与无栈协程等具体实现就能提纲挈领，无需在实现细节上纠结。</p><p>协程在实践中的实现方式千差万别，一个简单的原因是，协程本身可以通过许多基本元素构建。基本元素的选取方式不一样，构建出来的协程抽象也就有差别。例如，Lua语言选取了create、resume和yield作为基本构建元素，从调度器层面构建出所谓的“非对程”协程系统；而Julia语言绕过调度器，通过在协程内调用yieldto函数完成了同样的功能，构建出了一个所谓的对称协程系统。尽管这两种语言使用了同样的setjmp库，构造出来的原语却不一样。又如，许多C语言的协程库都使用了ucontext库实现，这是因为POSIX本身提供了ucontext库，不少协程实现是以ucontext为蓝本实现的。这些实现，都不可避免地带上了ucontext系统的一些基本假设，如协程间是平等的，一般带有调度器来协调协程等（如<a href="http://swtch.com/libtask/" target="_blank" rel="noopener">libtask</a>实现，以及云风的<a href="http://blog.codingnow.com/2012/07/c_coroutine.html" target="_blank" rel="noopener">coroutine</a>库）。Go语言的一个鲜明特色就是通道（channel）作为一级对象。因此，resume和yield等在其他语言里的原语在Go中都以通道方式构建。我们还可以举出诸多近似的例子。其风格差异往往和语言的历史、演化路径、要解决的问题相关，我们不必苛求其协程模型一定要如此这般。</p><p>总的来说，协程为协同任务提供了一种运行时抽象。这种抽象非常适合于协同多任务调度和数据流处理。在现代操作系统和编程语言中，因为用户态线程切换代价比内核态线程小，协程成为了一种轻量级的多任务模型。我们无法预测未来，但可以看到，协程已成为许多擅长数据处理语言的一级对象。随着计算机并行性能的提升，用户态任务调度已成为一种标准的多任务模型。在这样的大趋势下，协程这个简单且有效的模型就显得更加引人注目。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文原发于《程序员》2014年11月刊。好文章备份一份&lt;/p&gt;
&lt;p&gt;计算机科学是一门应用科学，几乎所有概念都是为了理解或解决实际问题而生的。协程 (Coroutine) 的出现也不例外。协程的概念，最早可以追溯到写作 COBOL 语言编译器中的技术难题。&lt;/p&gt;
&lt;h2 
      
    
    </summary>
    
    
      <category term="coroutine" scheme="https://hcendless.ink/tags/coroutine/"/>
    
  </entry>
  
  <entry>
    <title>什么是协程？</title>
    <link href="https://hcendless.ink/2020/05/05/coroutine/"/>
    <id>https://hcendless.ink/2020/05/05/coroutine/</id>
    <published>2020-05-05T08:33:57.000Z</published>
    <updated>2020-07-31T12:40:14.229Z</updated>
    
    <content type="html"><![CDATA[<p>Kotlin中的协程虽然会用，但也一直停留在表层Api。没有仔细探究过其思想以及实现，使用起来也会比较虚，心里没底。所以很有必要对其一探究竟，揭一揭它的面纱</p><h2 id="协程的定义"><a href="#协程的定义" class="headerlink" title="协程的定义"></a>协程的定义</h2><p>协程: Coroutine<br>协程的出现，可以追溯到1958年，它由马尔文·康威提出用于构建汇编程序，而且它的出现要早于线程。</p><p>定义<a href="https://en.wikipedia.org/wiki/Coroutine" target="_blank" rel="noopener">Wiki</a>:  :</p><blockquote><p><strong>Coroutines</strong> are computer program components that generalize subroutines for non-preemptive multitasking, by allowing execution to be suspended and resumed. Coroutines are well-suited for implementing familiar program components such as cooperative tasks, exceptions, event loops, iterators, infinite lists and pipes    </p></blockquote><blockquote><p>译: 协程时计算机程序的一类组件，通过允许挂起和恢复执行概括了非抢占式（即协作式）多任务的子程序。协程非常适合用于实现一些常见的程序组件，如协作式多任务，异常，事件循环，迭代器，无限列表以及管道</p></blockquote><p>Wiki中对于协程的定义还是挺难理解的，其中的关键词</p><ul><li>子程序（subroutine）  </li><li>挂起（suspend）和恢复（resume）</li><li>抢占式（preemptive）和协作式（cooperative or non-preemptive）  </li></ul><p>如果不先理解这几个关键词的话，是很难搞清楚协程的</p><h4 id="首先是子程序"><a href="#首先是子程序" class="headerlink" title="首先是子程序"></a>首先是子程序</h4><p>《The Art of Computer Programming》(计算机程序设计艺术)一书中对subroutine有详细的解释，以下是原文</p><blockquote><p>When a certain task is to be performed at severial different places in a program, it is usually undesirable to repeat the coding in each place. To avoid this situation, the coding (called a subroutine) can be put into one place only, and a few extra instructions can be added and to restart the outer program properly after the subroutine is finished    </p></blockquote><blockquote><p>译: 当一项确定的任务再程序的不同位置多次执行时，通常重复的代码不是我们想看到的。为了避免这种情况，这段代码（叫做一个子程序）可以被单独放在一个位置，通过少量额外的指令在每个需要执行该此程序的位置添加并执行子程序，并在子程序执行完成后，自动的重启外部程序</p></blockquote><p>这段对于子程序的描述还是很容易理解的，从高级语言的角度来看，子程序就相当于一个函数或方法，对子程序的引用即为对函数或方法的调用。</p><p>子程序的用途书中也有描述，这里简单提一下：子程序的主要优势是避免重复代码，节省程序空间。也间接的节省了时间，如：加载程序需要的时间减少等。子程序也会让构思大型程序变得更容易，debug也会更容易。封装出来的子程序也可以作为开放库对外暴露给其他开发者使用。</p><p>理解了子程序，那么子程序跟协程又有什么关系呢？或者说两者有什么区别呢？同样引用原文给出答案</p><blockquote><p>Subroutines are special case of more general program components, called coroutines. In contrast to the unsymmetric relationship between a main routine and a subroutine, there is complete symmetry between coroutines, which on call each other.    </p><p>We may consider the main program and subroutines as a team of programs, each member of the team having a certain job to do. The main program, in the course of doing its job, will activate the subprogram; the subprogram will perform its own function and then activate the main program. We may stretch our imagination to believe that, from the subroutine’s point of view, when it exits it is calling the main routine; the main routine continues to performs its duty, then ‘exits’ to the subroutine. the subroutine acts, then call the main routine again.</p></blockquote><p>译:     </p><blockquote><p>子程序是通用程序组件（即协程）的一种特例。与主程序与子程序间非对等关系（调用者与被调用者）对比，协程间是完全对等的，他们可以互相调用 </p></blockquote><blockquote><p>我们可以将主程序和子程序看作是程序组，程序组中的每个成员都要完成特定的任务。主程序在完成其任务的过程中，会激活子程序，然后子程序会执行完成它自己的任务，随后再激活主程序让主程序继续执行。拓展下我们的想象力，从子程序的视角出发，在子程序出口位置调用主程序，主程序继续执行其任务，接着主程序’退出’并在出口位置调用子程序，子程序执行，而后再调用主程序</p></blockquote><p>上面第二段的意思是，子程序只有一个入口和出口，而协程可以有多个入口和出口。即子程序被主程序调用后只能从头开始执行（入口）直到执行完成然后退出（出口），而后主程序继续执行。而协程在被调用后，在中途可能会有一个或多个出口（出口点之后仍然有代码待执行），当执行中途遇到出口时，当前协程交出执行权让其他协程执行，当下次再调用该协程时，会从上次的出口点位置继续开始执行后续的代码（上次的出口点即为下次执行的入口点）。这也就解释了第一段中子程序和主程序关系与协程间关系的差别了</p><blockquote><p>Wiki中子程序与协程的比较</p><ul><li>子例程可以调用其他子例程，调用者等待被调用者结束后继续执行，故而子例程的生命期遵循后进先出，即最后一个被调用的子例程最先结束返回。协程的生命期完全由对它们的使用需要来决定</li><li>子例程的起始处是惟一的入口点，每当子例程被调用时，执行都从被调用子例程的起始处开始。协程可以有多个入口点，协程的起始处是第一个入口点，每个yield返回出口点都是再次被调用执行时的入口点。</li><li>子例程只在结束时一次性的返回全部结果值。协程可以在yield时不调用其他协程，而是每次返回一部分的结果值，这种协程常称为生成器或迭代器。</li><li>现代的指令集架构通常提供对调用栈的指令支持，便于实现可递归调用的子例程。在以Scheme为代表的提供续体的语言环境下，恰好可用此控制状态抽象表示来实现协程。</li></ul></blockquote><h4 id="挂起和恢复"><a href="#挂起和恢复" class="headerlink" title="挂起和恢复"></a>挂起和恢复</h4><p>其实在子程序那一部分中已经对挂起和恢复做出了解释。协程拥有多个出口和入口，所谓挂起就是在执行途中遇到出口，当前协程让出执行权，跳转到其他协程继续执行，而恢复就是当再次调用该协程时从上次出口点继续执行后续任务。出口对应挂起，入口对应恢复</p><h4 id="抢占式和协作式"><a href="#抢占式和协作式" class="headerlink" title="抢占式和协作式"></a>抢占式和协作式</h4><p>首先，无论是抢占式还是协作式，都意味着当前Task都不再继续拥有执行权，而两者区别是，抢占式多任务中，当前任务被动的系统剥夺执行权，协作式多任务中，当前任务在不需要系统资源时主动让出执行权    </p><p>抢占式多任务涉及到了中断机制的使用，中断机制可以挂起当前进程并唤起调度器以决定接下来应该调度执行哪个进程。因此，所有进程在一段时间内都会获得一定数量的CPU时间</p><p>抢占式多任务依赖于 CPU 的硬件支持。 因为调度器需要“剥夺”进程的执行权，就意味着调度器需要运行在比普通进程高的权限上，否则任何“流氓（rogue）”进程都可以去剥夺其他进程了。只有 CPU 支持了执行权限后，抢占式调度才成为可能</p><p>不同于抢占式由系统调度进程切换，协作式进程在空闲（idel）或阻塞（block）时会主动的让出执行权（yield）</p><h2 id="协程能解决什么问题呢"><a href="#协程能解决什么问题呢" class="headerlink" title="协程能解决什么问题呢"></a>协程能解决什么问题呢</h2><p>如果从早先协程的设计理念来看，协程是设计用来处理单内核下多任务并发的。协程最本质的特性是可挂起和恢复的特性，拥有多入口多出口。<br>相较于子程序的从头运行至尾，协程有更丰富的过程（有一个或多个运行阶段）,多个任务可以交替执行，使得多任务协作提供成为可能，即协程拥有并发的能力。</p><p>而对于现代的高级语言来说，协程更像是任务，运行在线程之上，在语言级别进行调度。许多语言的也都是多线程 + 协程的的实现，以达到像写同步代码那样处理异步问题。通常异步需要多线程来实现，但是弊端就是多线程调度时，切换上下文较为耗时，而如果通过多线程 + 协程方式来处理异步的话，相当于将系统级的线程调度替换为语言级别的协程调度，一定程度上减少了多线程调度切换上下文的开销。另一方面，多线程方式实现异步最可能面临异步回调，而最熟悉的应该是JS中的回调地狱问题了，而有了协程之后，就可以完美的消除该问题。</p><h2 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h2><p>协程从本质上讲依然是一种程序，运行与线程之上。名称以及它表现出来的特征与线程有相似之处，但与线程不同的是，他的调度并不需要系统参与，而是直接在语言级别完成。这也是许多人称协程为用户级线程的原因</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Kotlin中的协程虽然会用，但也一直停留在表层Api。没有仔细探究过其思想以及实现，使用起来也会比较虚，心里没底。所以很有必要对其一探究竟，揭一揭它的面纱&lt;/p&gt;
&lt;h2 id=&quot;协程的定义&quot;&gt;&lt;a href=&quot;#协程的定义&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
    
      <category term="coroutine" scheme="https://hcendless.ink/tags/coroutine/"/>
    
  </entry>
  
  <entry>
    <title>GitHub Pages + Hexo搭建博客汇总</title>
    <link href="https://hcendless.ink/2019/08/18/hexo_github_pages/"/>
    <id>https://hcendless.ink/2019/08/18/hexo_github_pages/</id>
    <published>2019-08-18T06:57:05.176Z</published>
    <updated>2019-08-18T06:57:05.176Z</updated>
    
    <content type="html"><![CDATA[<p>网上关于GitHub Pages + Hexo搭建博客的教程较多，因此此文旨在查缺补漏，记录整个流程，汇总一些参考的优质blog，以及梳理我在搭建过程中遇到的问题。</p><h2 id="如何搭建个人blog"><a href="#如何搭建个人blog" class="headerlink" title="如何搭建个人blog"></a>如何搭建个人blog</h2><p>在开始之前，我先想了下如何搭建个人blog。既然blog是个网站，那么首先能想到的是，需要自己开发一个网站出来啊，有了网站，还需要服务器来部署我们的网站，然后还需要一个域名，方便访问我们的网站。    </p><h4 id="因此我们要做的工作有"><a href="#因此我们要做的工作有" class="headerlink" title="因此我们要做的工作有"></a>因此我们要做的工作有</h4><ul><li>开发自己的网站（网站设计，UI开发，评论统计系统集成维护等）</li><li>搭建服务器（部署网站，维护等）</li><li>购买域名（绑定域名）</li></ul><p>首先开发网赚需要耗费巨大精力，其次购买服务器和域名都需要花钱，而我的初衷只是写blog啊，然而却需要做这么多，那岂不是舍本逐末了。好在已经有现成且免费的框架和工具，GitHub Pages<br>和Hexo帮我们做了上面几乎所有的事儿</p><h4 id="GitHub-Pages介绍"><a href="#GitHub-Pages介绍" class="headerlink" title="GitHub Pages介绍"></a>GitHub Pages介绍</h4><p>GitHub Pages是Github提供的一个免费静态网站的托管服务，旨在直接从GitHub仓库托管个人/组织/项目的页面，并且为站点提供了默认域名github.io<br>。也就是说GitHub Pages帮我们解决了 <strong>服务器和域名</strong> 这两大难题</p><p>详细介绍：<a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages官网</a></p><h4 id="Hexo介绍"><a href="#Hexo介绍" class="headerlink" title="Hexo介绍"></a>Hexo介绍</h4><p>Hexo是一款基于Node.js的静态博客框架。通过Hexo，用户可以定制自己喜欢的网站主题，专注与使用Markdown编写blog，它会帮用户生成静态网站并托管在GitHub，相当的简便。因此Hexo帮我们解决了** 开发网站 ** 的难题</p><p>详细介绍：<a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">Hexo中文文档</a>  </p><h2 id="搭建个人blog的流程"><a href="#搭建个人blog的流程" class="headerlink" title="搭建个人blog的流程"></a>搭建个人blog的流程</h2><p>在使用Hexo极力推荐阅读** <a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">Hexo中文文档</a> ** ,文档里的说明要比许多blog里清晰的多</p><h4 id="搭建前的准备工作"><a href="#搭建前的准备工作" class="headerlink" title="搭建前的准备工作"></a>搭建前的准备工作</h4><p>安装流程在上文中的<a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">Hexo中文文档</a>里有详细说明</p><ul><li>安装Git</li><li>安装Node.js</li><li>安装Hexo  </li></ul><h4 id="搭建流程"><a href="#搭建流程" class="headerlink" title="搭建流程"></a>搭建流程</h4><p>这里只列出简单流程，定制主题，及git分支设置在后面介绍</p><ol><li><p>GitHub上创建新仓库，仓库名为 ** GitHub用户名.github.io **</p><blockquote><p>这里需要注意，仓库的名字必须为上面的格式，否则部署后将无法访问blog</p></blockquote></li><li><p>GitHub新建分支hexo，并设置为默认分支</p></li><li><p>使用Git克隆新建仓库到本地（此时为hexo分支）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/github_user_name/github_user_name.github.io.git</span><br></pre></td></tr></table></figure></li><li><p>在仓库根目录使用hexo init命令初始化（此时为hexo分支）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init</span><br></pre></td></tr></table></figure></li><li><p>上一步完成后依次使用hexo g 与 hexo s（此时为hexo分支），其中g为generator，s为server</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g</span><br><span class="line">$ hexo s</span><br></pre></td></tr></table></figure></li><li><p>打开浏览器输入localhost:4000查看本地blog效果，如下图</p><img src="/2019/08/18/hexo_github_pages/hexo_landscape.jpeg" title="Hexo默认主题"></li><li><p>修改仓库根目录下的_config.yml文件，修改deploy中的以下字段并保存，注意branch要设置为master</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span>    </span><br><span class="line"><span class="attr">    type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">    repo:</span> <span class="attr">https://github.com/github_user_name/github_user_name.github.io.git</span></span><br><span class="line"><span class="attr">    branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure></li><li><p>提交本地变更至hexo分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">'commit msg'</span></span><br><span class="line">$ git push origin hexo</span><br></pre></td></tr></table></figure></li><li><p>使用hexo d命令完成blog部署</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure></li></ol><h4 id="blog目录结构"><a href="#blog目录结构" class="headerlink" title="blog目录结构"></a>blog目录结构</h4><p>在上面流程的第4步中，执行完hexo init命令后，会在文件夹下生成hexo工程，以下简要展示生成的目录结构及各个目录的作用，更为详细的解释见<a href="https://hexo.io/zh-cn/docs/setup.html" target="_blank" rel="noopener">Hexo目录结构</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">|-- _config.yml      // 网站全局配置文件，详细说明见</span><br><span class="line">|-- package.json     //</span><br><span class="line">|-- scaffolds        //</span><br><span class="line">|-- source           // 网站资源文件夹，存放网站图片，文章等</span><br><span class="line">   |-- _drafts</span><br><span class="line">   |-- _posts        // 我们的Markdown和HTML文件存放在次文件夹</span><br><span class="line">|-- themes</span><br><span class="line">   |-- landscape     // 官方默认的主题</span><br><span class="line">   |-- next          // next主题</span><br></pre></td></tr></table></figure><p>经过第4步之后，通过修改_config.yml文件进行网站的配置,如网站title，author等，详情见<a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="noopener">Hexo网站配置</a>。其中最应该注意的是deploy字段，该字段用于配置网站的部署，如网站部署到git的xxx仓库的xxx分支，或是地址为xxx.xxx.xxx.xxx的服务器，详情见<a href="https://hexo.io/zh-cn/docs/deployment.html" target="_blank" rel="noopener">Hexo deploy</a>    </p><h4 id="设置主题"><a href="#设置主题" class="headerlink" title="设置主题"></a>设置主题</h4><p>Hexo允许用户自定义主题，下面展示主题的设置方式</p><ol><li><p>挑选自己喜欢的主题，找到其仓库地址</p></li><li><p>命令行cd 定位到themes文件夹，将主题clone至该文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> themes</span><br><span class="line">$ git <span class="built_in">clone</span> &lt;theme repo&gt;</span><br></pre></td></tr></table></figure></li><li><p>在clone完成后，新添加的文件夹名称即为主题名称xxx，打开_config.yml将theme字段的landscape修改为xxx</p></li></ol><p>关于主题的挑选，如果没有web前段经验，最好挑选那些star数计较高，社区比较活跃，经常迭代维护的主题，如我自己使用的next主题，下面是我在挑选主题时参考的资料   </p><p><a href="https://www.zhihu.com/question/24422335/answer/46357100" target="_blank" rel="noopener">知乎-有哪些好看的Hexo主题</a></p><blockquote><p>高赞回答用python爬虫爬出来的主题star排行榜 ,推荐参考这个挑选主题     </p></blockquote><p><a href="https://hexo.io/themes/index.html" target="_blank" rel="noopener">官方主题列表</a></p><blockquote><p>官方没有对主题进行排名，挑选时稍微麻烦些</p></blockquote><p><a href="https://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">推荐NexT主题</a></p><blockquote><p>NexT主题外观比较简洁利落，并且社区活跃，有详尽的中文文档，主题的外观也可进行各种灵活的配置，是前段盲的必备良药。对于该主题的详细用法，其官方文档中有详细的说明，也就不再赘述了</p></blockquote><h4 id="关于git仓库的说明"><a href="#关于git仓库的说明" class="headerlink" title="关于git仓库的说明"></a>关于git仓库的说明</h4><p>在搭建流程中的前两步，建立完仓库后，又新建了一个hexo分支，并且设置为默认分支。这是因为我们在维护我们的网站时，要维护以下两部分内容</p><ul><li><p>Hexo工程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init之后生成的部分</span><br></pre></td></tr></table></figure></li><li><p>生成的静态网站</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">之前在_config.yml中配置了deploy的git仓库及分支，这里我配置的是master分支，在执行了hexo deploy命令之后，Hexo就会生成静态静态网站提交至master分支并自动部署</span><br></pre></td></tr></table></figure></li></ul><p>这两部分都需要提交至git仓库的，第一部分提交至git，我们就可以随时随地只要有电脑网络就可以clone工程，写blog并更新网站。第二部分是GitHub Pages部署网站必须的部分。这两部分的内容互不相干，因此建议新建hexo分支，用于存储我们的Hexo工程，master分支用于部署网站</p><p>参考的文档：<a href="https://www.zhihu.com/question/21193762" target="_blank" rel="noopener">知乎-使用Hexo，如果换了电脑怎么更新博客</a></p><h4 id="关于NexT主题个人签名不显示的问题"><a href="#关于NexT主题个人签名不显示的问题" class="headerlink" title="关于NexT主题个人签名不显示的问题"></a>关于NexT主题个人签名不显示的问题</h4><p>在NexT主题配置文件_config.yml中，如果设置seo字段为true，则网站配置文件_config.yml中的description字段会被用于seo，而不会显示为签名，这时如果想要显示个人签名，需要额外添加signature字段</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">signature:</span> <span class="string">随行、随记</span></span><br></pre></td></tr></table></figure><h2 id="Hexo-SEO优化"><a href="#Hexo-SEO优化" class="headerlink" title="Hexo SEO优化"></a>Hexo SEO优化</h2><p>辛辛苦苦搭好了blog，写了文章，最后发现浏览器里搜不到啊，根本没人看啊，怎么办啊，好没有成就感。这时候就需要SEO出马了，那么什么是SEO呢？</p><blockquote><p>SEO 英文全称Search Engine Optimization 即搜索引擎优化。是一种利用搜索引擎规则提高网站在有关引擎内的自然排名</p></blockquote><p>既然是针对搜索引擎的优化，那么也就是针对Baidu和Google的优化了。相关blog有很多，并且都是死套路，所以这里就挑选几篇比较新比较好的blog列出来</p><p><a href="https://hoxis.github.io/Hexo+Next%20SEO%E4%BC%98%E5%8C%96.html" target="_blank" rel="noopener">Hexo博客Next主题SEO优化方法</a><br><a href="https://juejin.im/post/5ae7f8a2f265da0ba266c5c6" target="_blank" rel="noopener">Hexo个人博客SEO优化系列</a></p>]]></content>
    
    <summary type="html">
    
      网上关于GitHub Pages + Hexo搭建博客的教程较多，因此此文旨在查缺补漏，记录整个流程，汇总一些参考的优质blog，以及梳理我在搭建过程中遇到的问题。
    
    </summary>
    
      <category term="Web前端" scheme="https://hcendless.ink/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Hexo" scheme="https://hcendless.ink/tags/Hexo/"/>
    
      <category term="GitHub Pages" scheme="https://hcendless.ink/tags/GitHub-Pages/"/>
    
  </entry>
  
  <entry>
    <title>BIP 32</title>
    <link href="https://hcendless.ink/2018/09/27/bip32/"/>
    <id>https://hcendless.ink/2018/09/27/bip32/</id>
    <published>2018-09-27T09:29:35.000Z</published>
    <updated>2019-08-18T06:57:05.170Z</updated>
    
    <content type="html"><![CDATA[<p>此篇为BIP 32的译文，介绍分层确定性钱包<br><a href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki" target="_blank" rel="noopener">原文链接</a></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文介绍分层确定性钱包（HD Wallet）：一种可以在不同系统间部分或全部共享，有或没有花费的能力的钱包</p><p>该规范旨在为可在不同客户端之间通信的确定性钱包设定标准。虽然本文描述的钱包有很多特性，但对于钱包客户端来说并不是每个特性都需要实现    </p><p>本文分为两部分</p><ul><li>第一部分主要介绍如何从单一种子派生出一颗秘钥树</li><li>第二部分主要介绍如何利用派生出来的秘钥树构建钱包</li></ul><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><h4 id="非确定性钱包的缺点"><a href="#非确定性钱包的缺点" class="headerlink" title="非确定性钱包的缺点"></a>非确定性钱包的缺点</h4><p>现有的一些Bitcoin客户端使用随机生成的秘钥，为了避免为每笔交易后都进行备份，这些客户端会创建一个（默认）包含100个秘钥的秘钥池。并且这种钱包很难跨系统共享，或者多端同时使用。虽然可以使用钱包的加密特性隐藏私钥并且不共享密码，但是这也导致钱包失去了生成公钥的能力。</p><h4 id="确定性钱包及非确定钱包"><a href="#确定性钱包及非确定钱包" class="headerlink" title="确定性钱包及非确定钱包"></a>确定性钱包及非确定钱包</h4><p>确定性钱包不需要如此高频率的备份，而且由于椭圆曲线的数学特性，他可以在不暴露私钥的情况下计算出公钥。该特性就当于一个网络商店商家可以让他的服务器为每个顾客或每笔订单都生成一个新地址（即公钥hash），并且服务器不需要获取私钥。<br>然而，确定性钱包只有一条密钥对链组成。这个事实意味着钱包只能全部共享或不共享两种选择。但是在某些场景下我们只希望共享部分密钥（如只共享公钥）。还是拿网络商店举例，网络服务器并不需要访问商户的所有公钥，他们只需要获取用于接受客户付款的地址对应的公钥，而不是商户消费时生成的找零地址。而分层确定性钱包支持从单一root多条密钥链的特性，使得选择性的分享成为了可能。    </p><h2 id="密钥生成规范"><a href="#密钥生成规范" class="headerlink" title="密钥生成规范"></a>密钥生成规范</h2><h4 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h4><p>在本文的其余部分，我们将假定比特币中使用的公钥加密算法，即为secp256k1定义的字段和曲线参数椭圆曲线加密算法。变量如下</p><ul><li>整数模数曲线顺序（用n表示）</li><li>曲线上点的坐标</li><li>字节序列<br>另外两个坐标的加法（+）定义为EC组操作的应用<br>级联（||）是把一个字节序列附加到另一个字节序列的操作</li></ul><p>作为标准的转换函数，我们假设</p><ul><li>point(t):返回secp256k1基点与EC点做乘法（重复应用EC组操作）得到的坐标对与整数p。</li><li>ser32(i):把一个32位的无符号整数序列化为一个4字节序列，高位在前</li><li>ser256(p):把一个整数序列化为一个32字节序列，高位在前</li><li>serP(P):使用SEC1的压缩格式将坐标对p(x,y)序列化为字节序列：(0x02 or 0x03) || ser256(x),其中头部字节为y坐标的奇偶校验</li><li>parse256(p):将32字节序列转化为一个256位数字，高位字节优先</li></ul><h4 id="扩展密钥"><a href="#扩展密钥" class="headerlink" title="扩展密钥"></a>扩展密钥</h4><p>接下来，我们顶一个一个函数，该函数可以从一个给定的父密钥派生出一定数量的子密钥。为了防止派生密钥仅依赖父密钥本身，我们会额外加入一个256位的熵对私钥与公钥进行扩展。熵称之为链码，链码对于相应的公私钥是相同的，都为32字节<br>我们把一个扩展私钥表示为(k,c)，k为普通私钥，c为256位的熵。扩展公钥表示为(K,c)，其中K=point(k)，c为256位的熵<br>每个扩展密钥有2<sup>31</sup>个普通子密钥，以及2<sup>31</sup>个强化子密钥，每个密钥都有一个下标。普通密钥的下标为0 - 2<sup>31</sup>-1，强化密钥的下标为2<sup>31</sup> - 2<sup>32</sup>-1，为了方便，我们使用i(H)来标记强化密钥，i<sub>H</sub> = i + 2<sup>31</sup></p><h4 id="子密钥派生函数（CKD：child-key-derivation）"><a href="#子密钥派生函数（CKD：child-key-derivation）" class="headerlink" title="子密钥派生函数（CKD：child key derivation）"></a>子密钥派生函数（CKD：child key derivation）</h4><p>给定一个父扩展密钥及其下标i，可以计算出相应的子扩展密钥，算法取决于子扩展密钥是否是一个强化密钥（或即i是否&gt;=2^31），以及我们是否在讨论私钥或公钥</p><h6 id="父私钥-gt-子私钥"><a href="#父私钥-gt-子私钥" class="headerlink" title="父私钥 -&gt; 子私钥"></a>父私钥 -&gt; 子私钥</h6><p>函数CKDpriv((k<sub>par</sub>, c<sub>par</sub>), i) &rarr; (k<sub>i</sub>, c<sub>i</sub>)</p><ol><li>判断下标i是否大于等于2<sup>31</sup>，如果满足则为强化子密钥，计算I = HMAC-SHA512(Key = c<sub>par</sub>, Data = 0x00 || ser<sub>256</sub>(k<sub>par</sub>) || ser<sub>32</sub>(i))（注意：0x00为填充字节，保证私钥长度为33字节），如果不满足则为普通子密钥，计算I = HMAC-SHA512(Key = c<sub>par</sub>, Data = ser<sub>P</sub>(point(k<sub>par</sub>)) || ser<sub>32</sub>(i))</li><li>将I分为两个32字节序列，I<sub>L</sub>和I<sub>R</sub></li><li>返回的子密钥k<sub>i</sub> = parse<sub>256</sub>(I<sub>L</sub>) + k<sub>par</sub> (mod n)</li><li>链码(熵)c<sub>i</sub>为I<sub>R</sub></li><li>在parse<sub>256</sub>(I<sub>L</sub>) ≥ n 或 k<sub>i</sub> = 0的情况下，生成的密钥是无效的，这时应该继续计算下一个子密钥(发生的概率小于 1/2127)</li></ol><p>HMAC-SHA512函数，可查看<a href="http://tools.ietf.org/html/rfc4231" target="_blank" rel="noopener">RFC 4231</a></p><h6 id="父公钥-gt-子公钥"><a href="#父公钥-gt-子公钥" class="headerlink" title="父公钥 -&gt; 子公钥"></a>父公钥 -&gt; 子公钥</h6><p>函数CKDpub((K<sub>par</sub>, c<sub>par</sub>), i) &rarr; (K<sub>i</sub>, c<sub>i</sub>)，仅适用于普通子密钥</p><ol><li>判断下标i是否大于等于2<sup>31</sup>，如果满足则返回失败，如果不满足则为普通子密钥，计算I = HMAC-SHA512(Key = c<sub>par</sub>, Data = ser<sub>P</sub>(K<sub>par</sub>) || ser<sub>32</sub>(i))</li><li>将I分为两个32字节序列，I<sub>L</sub>和I<sub>R</sub></li><li>返回的子密钥k<sub>i</sub> = point(parse<sub>256</sub>(I<sub>L</sub>)) + K<sub>par</sub></li><li>链码(熵)c<sub>i</sub>为I<sub>R</sub></li><li>在parse<sub>256</sub>(I<sub>L</sub>) ≥ n 或 K<sub>i</sub>是无穷远的一个点时，这时应该继续计算下一个子密钥</li></ol><h6 id="父私钥-gt-子公钥"><a href="#父私钥-gt-子公钥" class="headerlink" title="父私钥 -&gt; 子公钥"></a>父私钥 -&gt; 子公钥</h6><p>函数N((k, c)) &rarr; (K, c)计算出与扩展私钥相对应的扩展公钥</p><ol><li>返回值K = point(k)</li><li>返回链码(熵)c即为函数输入中传递过来的链码</li></ol><p>两种通过父私钥计算子公钥的方法</p><ol><li>N(CKDpriv((k<sub>par</sub>, c<sub>par</sub>), i))(适用于任何条件)</li><li>CKDpub(N(k<sub>par</sub>, c<sub>par</sub>), i)（仅适用于生成普通子公钥）</li></ol><h6 id="父公钥-gt-子私钥"><a href="#父公钥-gt-子私钥" class="headerlink" title="父公钥 -&gt; 子私钥"></a>父公钥 -&gt; 子私钥</h6><p>不可能</p><h4 id="密钥树"><a href="#密钥树" class="headerlink" title="密钥树"></a>密钥树</h4><p>下一步我们使用若干个CKD结构构建一颗密钥树。从单一根节点开始，即主密钥m，对多个i计算CKDpriv(m,i)，进而得到1级派生子密钥。由于派生出来的密钥也都是扩展密钥，所以CKDpriv也可以应用于这些密钥。</p><p>为了方便书写，我们把CKDpriv(CKDpriv(CKDpriv(m,3<sub>H</sub>),2),5)简写为m/3<sub>H</sub>/2/5，同样的，对于公钥，我们把CKDpub(CKDpub(CKDpub(M,3),2),5)简写为M/3/2/5。因此有了下面的等式</p><ul><li>N(m/a/b/c) = N(m/a/b)/c = N(m/a)/b/c = N(m)/a/b/c = M/a/b/c.</li><li>N(m/a<sub>H</sub>/b/c) = N(m/a<sub>H</sub>/b)/c = N(m/a<sub>H</sub>)/b/c.</li></ul><p>但是，N(m/a<sub>H</sub>)不能写为N(m)/a<sub>H</sub>，因为我们无法通过父扩展公钥计算出子扩展私钥</p><p>每个叶子节点都对应于一个真正的密钥，叶子节点的链码会被忽略，只有节点中的公私钥是有用的。因为这种结构，我们有了父扩展私钥，就可以计算出所有的子扩展公钥及子扩展私钥，知道了父扩展公钥，就可以计算出所有的非强化子扩展公钥</p><h4 id="密钥id"><a href="#密钥id" class="headerlink" title="密钥id"></a>密钥id</h4><p>可以使用序列化的ECDSA公钥的Hash160作为扩展密钥的id，忽略链码。id对应于比特币中地址。不建议使用Base58对id进行编码，因为id可能被作为地址（并且钱包软件不需要接受对链密钥本身的付款）。</p><p>密钥id的钱32位称为指纹</p><h4 id="扩展密钥序列化格式"><a href="#扩展密钥序列化格式" class="headerlink" title="扩展密钥序列化格式"></a>扩展密钥序列化格式</h4><p>扩展公钥及扩展私钥格式如下</p><ol><li>4byte：版本号(主网: 0x0488B21E public, 0x0488ADE4 private; 测试网: 0x043587CF public, 0x04358394 private)</li><li>1byte：深度，根节点：0x00，一级节点：0x01 以此类推</li><li>4byte：父密钥的指纹(主密钥为0x00000000)</li><li>4byte：子节点个数(这里的英文看不懂 T T)</li><li>32byte：链码</li><li>33byte：原生公私钥数据(公钥部分为ser<sub>P</sub>(K)，私钥部分为0x00 || ser<sub>256</sub>(k))</li></ol><p>这78byte的数据可以像比特币其他数据一样使用Base58进行编码，首先要添加32位的校验码(通过两次SHA-256生成)，然后转为Base58编码格式，编码后输出长度为112位的字符串。版本号部分经过Base58编码，对应的字符串为，主网：xprv、xpub，测试网：tprv、tpub</p><p>注意：上面格式中父密钥的指纹仅为了方便软件(钱包)检测父子节点使用，并且软件需要处理冲突，在内部，可以使用完整的160位id。</p><p>在导入序列化扩展公钥时，必须验证公钥数据中的X坐标是否存在于椭圆曲线上。 如果不是，则扩展公钥无效</p><h4 id="主密钥生成"><a href="#主密钥生成" class="headerlink" title="主密钥生成"></a>主密钥生成</h4><p>可能的扩展密钥对总数几乎为2<sup>512</sup>，但是生成出来的密钥为256位，所以安全性会折半。主密钥并不是直接生成的，而是使用已有的种子代替。主密钥生成步骤如下：</p><ol><li>使用prng算法生成种子序列S，长度为128 - 512位之间。建议使用256位</li><li>计算I = HMAC-SHA512(Key = “Bitcoin seed”, Data = S)，直接使用比特币种子作为输入</li><li>将I分为两个32字节序列，I<sub>L</sub> and I<sub>R</sub></li><li>使用parse<sub>256</sub>(I<sub>L</sub>)作为主私钥，I<sub>R</sub>作为主链码</li></ol><p>在I<sub>L</sub> = 0 或 ≥n的情况下，生成的主密钥无效，需要重新生成</p><img src="/2018/09/27/bip32/derivation.png" title="主密钥生成"><h2 id="分层确定性钱包结构"><a href="#分层确定性钱包结构" class="headerlink" title="分层确定性钱包结构"></a>分层确定性钱包结构</h2><p>前面的部分中描述了密钥树及其节点，下一步是在此基础上构建一个钱包。本文中介绍的仅为一种范例，但是建议开发者开发钱包时模仿范例的兼容性，但也不是所有的功能都需要支持</p><h4 id="范例钱包的结构"><a href="#范例钱包的结构" class="headerlink" title="范例钱包的结构"></a>范例钱包的结构</h4><p>一个HDW可以看做一系列账户的集合，每个账户都有个编号，默认账户account(“”)的编码为0。钱包可以不支持多账户，如果不支持，则使用默认账户。</p><p>每个账户都是两条密钥链组成：内部链，外部链。外部链用来生成新的公共钱包地址，内部链可用于所有其他的操作(更改地址，生成地址，可以是任何不需要通信的操作)，支持双密钥链的钱包，应该使用外部链以支持所有的操作</p><ul><li>m/i<sub>H</sub>/0/k 为从主密钥m导出的第i个账号的外部链的第k个密钥对</li><li>m/i<sub>H</sub>/1/k 为从主密钥m导出的第i个账号的内部链的第k个密钥对</li></ul><h2 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h2><h4 id="全钱包共享"><a href="#全钱包共享" class="headerlink" title="全钱包共享"></a>全钱包共享</h4><p>在两个系统需要访问同一个钱包，并且两个系统都需要有花费的功能，则需要共享主扩展私钥。每个网络节点需要为外部链维护一个前瞻密钥缓池，其中保存n个前瞻密钥，用于监听收到的付款。对内部内部链的展望可能非常小，因为不存在任何缺口。注意账户名无法通过区块链同步，仍然需要手动输入。</p><h4 id="审计"><a href="#审计" class="headerlink" title="审计"></a>审计</h4><p>如果一名审计员需要获取所有交易(收支)记录，则可以将所有账户的扩展公钥共享给审计员。这样审计员就可以查看当前钱包的所有交易(收支)了</p><h4 id="公司多部门场景"><a href="#公司多部门场景" class="headerlink" title="公司多部门场景"></a>公司多部门场景</h4><p>当一家公司拥有数个独立的部门，则这些部门可以使用从同一主密钥派生出来的钱包。进而公司的领导通过维护一个超级钱包，就可以看到各个部门的收支情况了，甚至可以在各部门之间转移资金</p><h4 id="合作企业间交易"><a href="#合作企业间交易" class="headerlink" title="合作企业间交易"></a>合作企业间交易</h4><p>可以使用特定账户的外部链的扩展公钥作为“超级地址”，可以使得即使高频交易也不容易被别人追踪到，但无需为每笔付款都申请一个新地址。矿池操作员也可以使用这种机制作为可变支付地址</p><h4 id="不安全的收款人"><a href="#不安全的收款人" class="headerlink" title="不安全的收款人"></a>不安全的收款人</h4><p>当运行电子商务的服务器，存在安全风险时，他需要知道用于收款的公共地址。服务器只需要知道单个账户外部链扩展公钥。这意味着非法访问网络服务器的人最多只能查看交易记录，但是无法盗取资金，如果存在多台服务器，则他只攻破一台服务器，也无法访问到其它服务器的交易记录</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;此篇为BIP 32的译文，介绍分层确定性钱包&lt;br&gt;&lt;a href=&quot;https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a
      
    
    </summary>
    
    
      <category term="区块链" scheme="https://hcendless.ink/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="BIP" scheme="https://hcendless.ink/tags/BIP/"/>
    
  </entry>
  
  <entry>
    <title>BIP 39</title>
    <link href="https://hcendless.ink/2018/09/13/bip39/"/>
    <id>https://hcendless.ink/2018/09/13/bip39/</id>
    <published>2018-09-13T03:16:33.000Z</published>
    <updated>2019-08-18T06:57:05.173Z</updated>
    
    <content type="html"><![CDATA[<p>进入区块链行业已经一年有余，开发之余也一直在补充区块链知识，读过《区块链-技术驱动金融》，以及BTC白皮书BIP等，记录的比较零散，很有必要整理一下。首先先把比较重要的BIP翻译整理一遍。此篇BIP39的译文，是助记词相关知识</p><p><a href="https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki" target="_blank" rel="noopener">原文链接</a></p><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>此篇BIP介绍如何为确定性钱包生成助记词或者助记句（一组容易记忆的单词）<br>本文包括两部分：</p><ol><li>生成助记词</li><li>将助记词转化为二进制种子。种子可以用于生成BIP 32中所描述的确定性钱包</li></ol><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>原生的二进制信息/十六进制的钱包种子，对人们来说是很难记录并保存的，而且在保存的过程中也容易出错。如果换成一组单词或句子，则友好的多。句子可以很方便的写在纸上或其他隐秘的地方</p><h2 id="生成助记词"><a href="#生成助记词" class="headerlink" title="生成助记词"></a>生成助记词</h2><h4 id="第一步-–-生成初始熵"><a href="#第一步-–-生成初始熵" class="headerlink" title="第一步 – 生成初始熵"></a>第一步 – 生成初始熵</h4><p>熵的位数必须为32的整数倍。熵越长，越安全，相应的助记词也就越多。这里定位熵的长度为ENT，ENT的取值范围为128位-256位</p><h4 id="第二步-–-计算校验和"><a href="#第二步-–-计算校验和" class="headerlink" title="第二步 – 计算校验和"></a>第二步 – 计算校验和</h4><p>计算方式，对初始熵计算SHA256 hash，取其前 ENT/32 位作为校验和CS。</p><h4 id="第三部-–-生成助记词"><a href="#第三部-–-生成助记词" class="headerlink" title="第三部 – 生成助记词"></a>第三部 – 生成助记词</h4><p>然后将校验和拼接在初始熵的尾部，即ENT+CS位数据，再划分为整数个11bit组，即（ENT+CS）/ 11组，记为MS，每个组可以编码为0-2047中的一个正整数，刚好对应于助记词表中的一个单词的下标。然后将分组按照下标转换为一组助记词</p><p>下图描述了ENT，CS，MS的关系    </p><img src="/2018/09/13/bip39/ENT-CS-MS.png"><h4 id="助记词表"><a href="#助记词表" class="headerlink" title="助记词表"></a>助记词表</h4><p>一个理想的助记词表应该拥有以下特性</p><ol><li><p>选词聪明</p><blockquote><p>所选的词应该满足通过单词的前四个字符就可以确定该单词    </p></blockquote></li><li><p>避免相近次出现</p><blockquote><p>如’build’/‘built’、’woman’/‘women’、’quick’/‘quickly’。这类相似词，不仅让记忆句子变得困难，而且也更容易出错</p></blockquote></li><li><p>助记词列表需要排序</p><blockquote><p>有序的助记词列表，可以让词查找更加有效率，同时也可以使用前缀树，以便更好的压缩</p></blockquote></li></ol><p>注：助记词表可以包含本地字符，但是必须使用（NFKD）UTF-8编码</p><h2 id="助记词转化为种子（seed）"><a href="#助记词转化为种子（seed）" class="headerlink" title="助记词转化为种子（seed）"></a>助记词转化为种子（seed）</h2><p>有些用户可能想用passphrase对助记词进行加密。如果没有设置passphrase则使用“”空字符代替<br>生成种子使用的是<strong>PBKDF2</strong>算法该算法的<br>该算法的输入为</p><ul><li>助记词作为password参数</li><li>“mnemonic”+passphrase作为salt参数</li><li>迭代次数设置为2048</li><li>使用HMAC-SHA512作为伪随机数生成函数    </li></ul><p>输出为</p><ul><li>512位的种子</li></ul><p>种子用于生成BIP 32中描述的确定性钱包（HD Wallet）    </p><p>由于seed的生成完全独立于mnemonic的生成，这使得代码非常简洁。并且对助记词没有任何限制，用户可以实现自己的单词表，甚至是整个助记词的生成</p><p>虽然可以使用其他算法生成的助记符，但不建议这样做，并且APP中必须使用助记词表计算助记词的校验和，如果无效则应该提示用户。</p><p>注：错误的passphrase虽然也能生成有效的seed，并且生成钱包，但只有正确的passphrase生成的seed，才能获取到拥有财产的钱包</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;进入区块链行业已经一年有余，开发之余也一直在补充区块链知识，读过《区块链-技术驱动金融》，以及BTC白皮书BIP等，记录的比较零散，很有必要整理一下。首先先把比较重要的BIP翻译整理一遍。此篇BIP39的译文，是助记词相关知识&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https:/
      
    
    </summary>
    
    
      <category term="区块链" scheme="https://hcendless.ink/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="BIP" scheme="https://hcendless.ink/tags/BIP/"/>
    
  </entry>
  
  <entry>
    <title>scala中的函数</title>
    <link href="https://hcendless.ink/2018/07/23/scala%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/"/>
    <id>https://hcendless.ink/2018/07/23/scala中的函数/</id>
    <published>2018-07-23T06:31:46.000Z</published>
    <updated>2020-07-31T12:40:12.298Z</updated>
    
    <content type="html"><![CDATA[<p>在各类blog及scala书籍中看到的关于函数最多的一句话是</p><blockquote><p>函数是一等公民</p></blockquote><p>可以看出函数在scala中举足轻重的地位，因此很有必要去全面的掌握它</p><h2 id="scala函数基础"><a href="#scala函数基础" class="headerlink" title="scala函数基础"></a>scala函数基础</h2><h4 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h4><ul><li><p>匿名函数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> (x: Int) =&gt; x + 1</span></span><br><span class="line">res0: Int =&gt; Int = $$Lambda$1026/1792711692@7412ed6b</span><br></pre></td></tr></table></figure><p>固定写法：左边是参数列表，中间符号=&gt;，右边是函数体<br>匿名函数无函数名，也无需给出函数的结果类型</p></li><li><p>函数字面量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val f = (x: Int) =&gt; x + 1</span></span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> f(10)</span></span><br><span class="line">res0: Int = 11</span><br></pre></td></tr></table></figure><p>其中表达式有半部分为一个匿名函数，函数作为一个变量(或不变量)，用变量名+参数表方式调用，与普通方法的调用几乎相同。<br>** 需要注意的是函数字面量声明函数时不需要写出函数的返回值类型，函数体的最后一条表达式的结果会作为返回值返回 **</p></li><li><p>函数值<br>函数字面量与函数值的关系就像类与对象的关系。函数字面量其实就是一个实现了trait Function*的函数类，在运行时实例化了一个函数类，这个实例就是函数值</p></li></ul><h4 id="函数的本质"><a href="#函数的本质" class="headerlink" title="函数的本质"></a>函数的本质</h4><p>scala不像java有基本类型与引用类型之分，scala中一切皆对象，包括函数也是对象。scala中定义了一系列trait，Function0 - Function22，其中0-22表示参数的个数(至于为什么是到22，理论上讲程序中不会出现多于22个参数的函数)。而函数正是Function<em>的实例。如<code>val f = (x: Int) =&gt; x + 1</code>其实就是Function1的实例。下面看下Function</em>的源码，以Function3为例</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** A function of 3 parameters.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Function3</span>[-<span class="type">T1</span>, -<span class="type">T2</span>, -<span class="type">T3</span>, +<span class="type">R</span>] <span class="keyword">extends</span> <span class="title">AnyRef</span> </span>&#123; self =&gt;</span><br><span class="line">  <span class="comment">/** Apply the body of this function to the arguments.</span></span><br><span class="line"><span class="comment">   *  @return   the result of function application.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(v1: <span class="type">T1</span>, v2: <span class="type">T2</span>, v3: <span class="type">T3</span>): <span class="type">R</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Creates a curried version of this function.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   *  @return   a function `f` such that `f(x1)(x2)(x3) == apply(x1, x2, x3)`</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@annotation</span>.unspecialized <span class="function"><span class="keyword">def</span> <span class="title">curried</span></span>: <span class="type">T1</span> =&gt; <span class="type">T2</span> =&gt; <span class="type">T3</span> =&gt; <span class="type">R</span> = &#123;</span><br><span class="line">    (x1: <span class="type">T1</span>) =&gt; (x2: <span class="type">T2</span>) =&gt; (x3: <span class="type">T3</span>) =&gt; apply(x1, x2, x3)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Creates a tupled version of this function: instead of 3 arguments,</span></span><br><span class="line"><span class="comment">   *  it accepts a single [[scala.Tuple3]] argument.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   *  @return   a function `f` such that `f((x1, x2, x3)) == f(Tuple3(x1, x2, x3)) == apply(x1, x2, x3)`</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@annotation</span>.unspecialized <span class="function"><span class="keyword">def</span> <span class="title">tupled</span></span>: <span class="type">Tuple3</span>[<span class="type">T1</span>, <span class="type">T2</span>, <span class="type">T3</span>] =&gt; <span class="type">R</span> = &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Tuple3</span>(x1, x2, x3) =&gt; apply(x1, x2, x3)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span></span>() = <span class="string">"&lt;function3&gt;"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到其中有一个apply方法(先忽略其他方法)，接受三个泛型参数，所以当我们调用<code>f(1)</code>时，其实是调用了Function1实例的apply方法。</p><h4 id="函数与方法"><a href="#函数与方法" class="headerlink" title="函数与方法"></a>函数与方法</h4><p>在学习过程中，还有一点很困扰，就是我们在类中用def定义的是不是函数，如果不是函数，它又是什么，跟函数又有什么区别呢？<br>首先呢使用def 关键字定义的是方法，不是函数，虽然在实际应用中几乎没有差别，但还是需要了解两者的不同的    </p><p>** 方法 **<br>定义在类中，作为某个对象的成员方法，使用def关键字定义</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> def a(x: Int):Int = x + 1</span></span><br><span class="line">a: (x: Int)Int</span><br></pre></td></tr></table></figure><p>** 两者的区别 **</p><ul><li>方法使用def关键字定义，而函数不用(函数使用val/var或干脆匿名)</li><li>方法是类的一部分，函数是对象可以赋值给一个val/var</li><li>函数作为对象可以像任何其他数据类型一样被传递和操作，而方法不行，如果想要传递方法，则需要把方法转换为函数</li><li>定义方法时，如果没有参数，则参数表可以省略不写(即方法名后不写())，而函数不行</li><li>定义函数时参数列表后不能声明结果类型，如下面的写法会编译错误<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> f(x: Int):Int =&gt; x + 1</span></span><br><span class="line">&lt;console&gt;:1: error: ';' expected but '=&gt;' found.</span><br><span class="line">       f(x: Int):Int =&gt; x + 1</span><br><span class="line">                     ^</span><br></pre></td></tr></table></figure></li></ul><p>** 两者的转换 **</p><ul><li><p>第一种情况，方法直接转为函数<br>不能将方法直接声明为一个val/var，如下面的写法会编译错误</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> def m(x: Int):Int = x + 1</span></span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val f = m</span></span><br><span class="line">&lt;console&gt;:12: error: missing argument list for method m</span><br><span class="line">Unapplied methods are only converted to functions when a function type is expected.</span><br><span class="line">You can make this conversion explicit by writing `m _` or `m(_)` instead of `m`.</span><br><span class="line">       val f = m</span><br></pre></td></tr></table></figure><p>正确写法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> def m(x: Int):Int = x + 1</span></span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val f = m _</span></span><br><span class="line">f: Int =&gt; Int = $$Lambda$1069/727861082@4990b335</span><br></pre></td></tr></table></figure><p>这个转换的其实是使用了部分应用(Partial Applied Function)，下面将会讲到</p></li><li><p>第二种情况，需要函数的地方使用方法<br>这种情况下不需要使用下划线，方法会被自动转换为函数，称之为eta转换。关于eta-expansion与eta-conversion的解释可以参考<a href="http://hongjiang.info/scala-eta-conversion/" target="_blank" rel="noopener">王宏江-scala中的eta-conversion</a>与<a href="https://hongjiang.info/eta-conversion-and-eta-expansion/" target="_blank" rel="noopener">王宏江-再谈eta-conversion与eta-expansion</a></p></li></ul><h2 id="scala函数进阶"><a href="#scala函数进阶" class="headerlink" title="scala函数进阶"></a>scala函数进阶</h2><h4 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h4><p>引用<a href="https://zh.wikipedia.org/wiki/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">维基百科</a>中高阶函数的定义</p><blockquote><p>在数学和计算机科学中，高阶函数是至少满足下列一个条件的函数：    </p></blockquote><ul><li>接受一个或多个函数作为输入    </li><li>输出一个函数    </li></ul><p>定义应该很容易理解，也就是函数可以接受另一个函数作为参数，或者函数的结果类型为函数类型。    </p><ul><li><p>第一种：如数学中的函数<code>f(x) = x + 1</code>， <code>g(x) = x * 2</code>，则<code>f(g(x)) = (x * 2) + 1</code>, 即为高阶函数。用代码实现即为</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">g</span></span>(x: <span class="type">Int</span>) = x * <span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span></span>(x: <span class="type">Int</span>, g: <span class="type">Int</span> =&gt; <span class="type">Int</span>) = g(x) + <span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p>第二种：结果类型为函数类型</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">g</span></span>(x: <span class="type">Int</span>):(<span class="type">Int</span> =&gt; <span class="type">Int</span>) = &#123;</span><br><span class="line">  <span class="keyword">val</span> k = x * <span class="number">2</span></span><br><span class="line">  (y: <span class="type">Int</span>) =&gt; y + k + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="函数的部分应用"><a href="#函数的部分应用" class="headerlink" title="函数的部分应用"></a>函数的部分应用</h4><p>先看下代码如何实现函数的部分应用吧</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> def sum(x: Int, y: Int, z: Int) = x + y + z</span></span><br><span class="line">sum: (x: Int, y: Int, z: Int)Int</span><br><span class="line"></span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val a = sum _</span></span><br><span class="line">a: (Int, Int, Int) =&gt; Int = $$Lambda$1055/565627330@309cedb6</span><br><span class="line"></span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> a(1,2,3)</span></span><br><span class="line">res0: Int = 6</span><br><span class="line"></span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val b = sum(1, _: Int, _: Int)</span></span><br><span class="line">b: (Int, Int) =&gt; Int = $$Lambda$1060/605472344@6d5f4900</span><br><span class="line"></span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> b(2,3)</span></span><br><span class="line">res1: Int = 6</span><br></pre></td></tr></table></figure><p>上面代码中出现了两种写法</p><ul><li>写法一<br><code>val a = sum _</code><br>这行代码表示sum方法的三个参数都为给出，整个参数表都用占位符<code>_</code>代替，所以这行代码的效果其实就是讲方法sum转换为了函数a。与之相同的写法还有<br><code>val a = sum(_)</code></li><li>写法二<br><code>val b = sum(1, _: Int, _: Int)</code><br>这行代码表示，已知三个参数中的x，y和z未给出，用占位符<code>_</code>代替，最后返回一个包含了两个参数的函数b    </li></ul><p>部分应用从数学角度理解比较容易，如上面例子中的sum，其实对应于数学中的<code>sum(x,y,z) = x + y + z</code>，这是一个三元函数(既有三个未知数)，而写法二对sum的部分应用，相当于我们现在得知<code>x = 1</code>，则带入函数得<code>sum(y,z) = 1 + y + z</code>，也就是函数f消去了未知元x。** 整体来看函数的部分应用其实就是数学中的消元。 ** 而写法是对未消去任何参数的一种简写</p><h4 id="函数的柯里化"><a href="#函数的柯里化" class="headerlink" title="函数的柯里化"></a>函数的柯里化</h4><p>在scala中函数函数可以有多个参数列表，而函数柯里化就是将函数的多参数列表转换为多个多参数列表。写法如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> def sum(x: Int, y: Int) = x + y</span></span><br><span class="line">sum: (x: Int, y: Int)Int</span><br><span class="line"></span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val a = sum _</span></span><br><span class="line">a: (Int, Int) =&gt; Int = $$Lambda$1075/571435580@5eb041b5</span><br><span class="line"></span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val b = a.curried</span></span><br><span class="line">b: Int =&gt; (Int =&gt; Int) = scala.Function2$$Lambda$1076/1263872787@524dd373</span><br></pre></td></tr></table></figure><p>柯里化是通过调用函数对象的curried方法实现的。也就是说调用的是Function*中的curried方法(Function2-Function22拥有curried方法，Function0及Function1没有，因为无参函数和但参函数不需要也不能柯里化)，以Function2为例，我们看下源码的实现</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Function2</span>[-<span class="type">T1</span>, -<span class="type">T2</span>, +<span class="type">R</span>] <span class="keyword">extends</span> <span class="title">AnyRef</span> </span>&#123; self =&gt;</span><br><span class="line">  ...</span><br><span class="line">  <span class="meta">@annotation</span>.unspecialized <span class="function"><span class="keyword">def</span> <span class="title">curried</span></span>: <span class="type">T1</span> =&gt; <span class="type">T2</span> =&gt; <span class="type">R</span> = &#123;</span><br><span class="line">    (x1: <span class="type">T1</span>) =&gt; (x2: <span class="type">T2</span>) =&gt; apply(x1, x2)</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>curried的实现是将一个多参函数转换为一个单参函数的函数链，对于上面的例子来说就是把<code>sum(x,y)</code>转换成了<code>sum(x)(y)</code>，<code>sum(1)(2)</code>也就是对两个单参函数的依次调用，而<code>sum(1)</code>或者<code>sum(2)</code>其实相当于对sum函数的部分应用，返回值是一个单参函数</p><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>引用别人blog中对闭包的定义</p><blockquote><p>闭包是一个函数，返回值依赖于声明在函数外部的一个或多个变量。</p></blockquote><p>示例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> var more = 1</span></span><br><span class="line">more: Int = 1</span><br><span class="line"></span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val add = (i: Int) =&gt; i + more</span></span><br><span class="line">add: Int =&gt; Int = $$Lambda$1045/640294829@6be6931f</span><br></pre></td></tr></table></figure><p>上面例子中add函数的计算依赖于自由变量more，也就是闭包了。闭包很像函数字面量，不同的是，闭包运算的过程不只依赖于输入参数，还需要依赖函数之外的一个或多个自由变量。</p><p>关于闭包的详细解释可以参考<a href="https://zhuanlan.zhihu.com/p/21346046" target="_blank" rel="noopener">知乎-什么是闭包</a>，引用博文中的总结</p><blockquote><p>最简洁、直击要害的回答，我能想到的分别有这么三句（版权属于 ：</p></blockquote><ul><li>闭包是一个有状态（不消失的私有数据）的函数。</li><li>闭包是一个有记忆的函数。</li><li>闭包相当于一个只有一个方法的紧凑对象（a compact object）。</li></ul><p>上面这三句话是等价的</p><h4 id="嵌套函数"><a href="#嵌套函数" class="headerlink" title="嵌套函数"></a>嵌套函数</h4><p>scala允许在函数内部定义函数，称之为局部函数。它的作用域仅限于外部函数，其他位置无法访问到内部函数，可以达到控制访问的效果<br>示例</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> f = (x:<span class="type">Int</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">val</span> innerAdd = (i: <span class="type">Int</span>) =&gt; i + <span class="number">1</span></span><br><span class="line">  innerAdd(x) + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>关于scala中的函数，就先写这么多吧，等到后面开发应用到其他的知识，在作补充。关于函数的部分应用和柯里化的实际意义，在<a href="../../21/scala函数式编程/">scala函数式编程</a>那篇里写出来<br>，这里就不写了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在各类blog及scala书籍中看到的关于函数最多的一句话是&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;函数是一等公民&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以看出函数在scala中举足轻重的地位，因此很有必要去全面的掌握它&lt;/p&gt;
&lt;h2 id=&quot;scala函数基础&quot;
      
    
    </summary>
    
      <category term="scala" scheme="https://hcendless.ink/categories/scala/"/>
    
    
      <category term="scala" scheme="https://hcendless.ink/tags/scala/"/>
    
  </entry>
  
  <entry>
    <title>scala函数式编程</title>
    <link href="https://hcendless.ink/2018/07/21/scala%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>https://hcendless.ink/2018/07/21/scala函数式编程/</id>
    <published>2018-07-21T08:18:04.000Z</published>
    <updated>2019-08-18T06:57:05.180Z</updated>
    
    <content type="html"><![CDATA[<p>从java转向scala已经有一段时间了，虽然平时写代码问题不大，但是因为面向对象编程已经根深蒂固了，一直对函数式编程理解不是很到位，scala虽然是多范式编程语言，但是官方还是鼓励开发者使用函数式编程的，所以很有必要仔细学习并记录一下</p><h2 id="什么是函数式"><a href="#什么是函数式" class="headerlink" title="什么是函数式"></a>什么是函数式</h2><p>函数式编程，不是某一种语言的特性，而是诸多编程思想(如命令式，面向对象等)中的一种。对于它的解释，引用<a href="(http://www.10tiao.com/html/557/201609/2652725732/1.html)">王宏江-Scala中的函数式特性</a>中的一段话</p><blockquote><p>图灵机，以及冯诺依曼对它的实现（冯诺依曼体系），从风格上被归为“命令式”，它的运算过程可以看作不断地修改内存来反映运算的结果，即用命令修改状态；而阿隆佐邱奇提出的 Lambda 演算，则是通过连续的运算（基于函数）得到最终结果。<br>基于Lambda演算的被归为函数式，在众多的函数式编程语言里，Scala的血缘继承自ML 和Haskell 最多。关于ML有本非常好的书《ML for the Working Programmer》，这本书里面提到:<strong>“函数式程序是跟值打交道的，而不是跟状态打交道的。它们的工具是表达式，而不是命令。”</strong></p></blockquote><h4 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h4><p>上面引文里，函数式程序的工具是表达式，那么什么是表达式呢？<br>表达式可以简单理解为有返回值的语句。在scala中只有表达式，因为在scala中任何语句都有返回值，而在java中则不是。如赋值语句在scala中是有返回值的，返回类型为Unit，而在java中赋值语句没有返回值<br>示例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span> var b = 1</span><br><span class="line">b: Int = 1</span><br><span class="line"></span><br><span class="line"><span class="meta">scala&gt;</span> val a = b = 3</span><br><span class="line">a: Unit = ()</span><br></pre></td></tr></table></figure><p>变量b被重新赋值为3，赋值的结果类型为Unit，并且赋值给了a</p><h4 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h4><p>函数式编程就是把计算机中的运算抽象为数学中的运算，程序中的函数和方法抽象为数学中的函数。如       </p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span></span>(x: <span class="type">Int</span>):<span class="type">Int</span> = &#123;</span><br><span class="line">  <span class="number">3</span>X + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">对应于数学中的</span><br><span class="line"></span><br><span class="line">f(<span class="type">X</span>) = <span class="number">3</span>X + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>函数的参数即为数学函数中的未知数(x或y等等)，整个运算过程封装在函数体中，并且不需要依赖除了参数外的其他数据，运算完成后返回运算的结果。  </p><p>对于复杂的运算，抽象为多个函数的嵌套调用，整个运算的过程都是围绕函数进行的，摒弃了命令式编程中对状态的依赖，这也是为什么scala鼓励我们使用val不变量，而尽量少使用var变量</p><p>最终整个应用程序都是由一个一个的函数组成</p><p>为了支持函数式编程，scala中提供了很多函数特性，这些特性在<a href="../../23/scala中的函数/">scala中的函数那篇blog</a>里，简单罗列下</p><ul><li>引入了与其他类型地位平等的函数类型，函数可传递，可作为返回值</li><li>对高阶函数的支持</li><li>函数的部分应用</li><li>函数柯里化</li><li>函数嵌套</li><li>闭包</li></ul><h2 id="函数式编程的特性"><a href="#函数式编程的特性" class="headerlink" title="函数式编程的特性"></a>函数式编程的特性</h2><p>关于函数式编程的特性可以参考<a href="http://www.ruanyifeng.com/blog/2012/04/functional_programming.html" target="_blank" rel="noopener">阮一峰-函数式编程初探</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从java转向scala已经有一段时间了，虽然平时写代码问题不大，但是因为面向对象编程已经根深蒂固了，一直对函数式编程理解不是很到位，scala虽然是多范式编程语言，但是官方还是鼓励开发者使用函数式编程的，所以很有必要仔细学习并记录一下&lt;/p&gt;
&lt;h2 id=&quot;什么是函数式
      
    
    </summary>
    
      <category term="scala" scheme="https://hcendless.ink/categories/scala/"/>
    
    
      <category term="scala" scheme="https://hcendless.ink/tags/scala/"/>
    
      <category term="函数式" scheme="https://hcendless.ink/tags/%E5%87%BD%E6%95%B0%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>scala学习资料整理</title>
    <link href="https://hcendless.ink/2018/07/21/scala%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/"/>
    <id>https://hcendless.ink/2018/07/21/scala学习资料整理/</id>
    <published>2018-07-21T07:57:35.000Z</published>
    <updated>2020-05-05T08:27:41.359Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p><strong><a href="https://twitter.github.io/scala_school/" target="_blank" rel="noopener">twitter scala school</a></strong> Scala课堂是Twitter启动的一系列讲座，用来帮助有经验的工程师成为高效的Scala 程序员<br><strong><a href="http://twitter.github.io/effectivescala/" target="_blank" rel="noopener">twitter - Effective Scala</a></strong> Twitter的Scala最佳实践    </p><h2 id="优质blog"><a href="#优质blog" class="headerlink" title="优质blog"></a>优质blog</h2><p><strong><a href="https://hongjiang.info/scala/" target="_blank" rel="noopener">王宏江scala系列</a></strong><br>**<a href="http://www.lihaoyi.com/" target="_blank" rel="noopener">李浩毅blog</a></p><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p><strong><a href="https://scala.cool/" target="_blank" rel="noopener">Scala中的集合</a></strong><br><strong><a href="https://alexn.org/blog/2017/01/13/traversable.html" target="_blank" rel="noopener">Why scala.collection.Traversable Is Bad Design</a></strong><br><strong><a href="http://colobu.com/2016/11/17/Benchmarking-Scala-Collections/" target="_blank" rel="noopener">Scala Collection的性能(李浩毅blog的译文)</a></strong></p><h4 id="零散"><a href="#零散" class="headerlink" title="零散"></a>零散</h4><p><strong><a href="https://my.oschina.net/joymufeng/blog/863823" target="_blank" rel="noopener">Scala中的下划线</a></strong></p><h5 id="持续更新中…"><a href="#持续更新中…" class="headerlink" title="持续更新中…"></a>持续更新中…</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://twitter.github.io/scala_school/&quot; target=&quot;_bla
      
    
    </summary>
    
      <category term="scala" scheme="https://hcendless.ink/categories/scala/"/>
    
    
      <category term="scala" scheme="https://hcendless.ink/tags/scala/"/>
    
  </entry>
  
</feed>
